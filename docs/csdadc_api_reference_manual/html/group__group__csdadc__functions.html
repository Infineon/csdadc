<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cypress CSDADC Middleware Library 2.0: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="cypress_logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cypress CSDADC Middleware Library 2.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__csdadc__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>This section describes the CSDADC Function Prototypes. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga539700892c4ce6ca9c0d076a53a796a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#ga539700892c4ce6ca9c0d076a53a796a9">Cy_CSDADC_Init</a> (const <a class="el" href="structcy__stc__csdadc__config__t.html">cy_stc_csdadc_config_t</a> *config, <a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *context)</td></tr>
<tr class="memdesc:ga539700892c4ce6ca9c0d076a53a796a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Captures the CSD HW block and configures it to the default state, is called by the application program prior to calling any other function of the middleware.  <a href="#ga539700892c4ce6ca9c0d076a53a796a9">More...</a><br /></td></tr>
<tr class="separator:ga539700892c4ce6ca9c0d076a53a796a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace0ef0fd816a147c2821877644da81b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#gace0ef0fd816a147c2821877644da81b7">Cy_CSDADC_Enable</a> (<a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *context)</td></tr>
<tr class="memdesc:gace0ef0fd816a147c2821877644da81b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the CSDADC firmware modules.  <a href="#gace0ef0fd816a147c2821877644da81b7">More...</a><br /></td></tr>
<tr class="separator:gace0ef0fd816a147c2821877644da81b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4df6d98c1998f7e88f41fc4277c61c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#gaf4df6d98c1998f7e88f41fc4277c61c0">Cy_CSDADC_DeInit</a> (<a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *context)</td></tr>
<tr class="memdesc:gaf4df6d98c1998f7e88f41fc4277c61c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the middleware operation and releases the CSD HW block.  <a href="#gaf4df6d98c1998f7e88f41fc4277c61c0">More...</a><br /></td></tr>
<tr class="separator:gaf4df6d98c1998f7e88f41fc4277c61c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e9f532bc47f4444a10d67fe0cea56cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#ga1e9f532bc47f4444a10d67fe0cea56cd">Cy_CSDADC_WriteConfig</a> (const <a class="el" href="structcy__stc__csdadc__config__t.html">cy_stc_csdadc_config_t</a> *config, <a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *context)</td></tr>
<tr class="memdesc:ga1e9f532bc47f4444a10d67fe0cea56cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the CSDADC middleware with the desired configuration.  <a href="#ga1e9f532bc47f4444a10d67fe0cea56cd">More...</a><br /></td></tr>
<tr class="separator:ga1e9f532bc47f4444a10d67fe0cea56cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6088c5e8f20c4a1e46553fd918b4c9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#gac6088c5e8f20c4a1e46553fd918b4c9e">Cy_CSDADC_RegisterCallback</a> (<a class="el" href="group__group__csdadc__data__structures.html#gae57e5fc50d39777f67c3cb8d9c176315">cy_csdadc_callback_t</a> callbackFunction, <a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *context)</td></tr>
<tr class="memdesc:gac6088c5e8f20c4a1e46553fd918b4c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback function, which notifies that a callback event occurred in the CSDADC middleware.  <a href="#gac6088c5e8f20c4a1e46553fd918b4c9e">More...</a><br /></td></tr>
<tr class="separator:gac6088c5e8f20c4a1e46553fd918b4c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga396e74d40e771e25a617d88f08c0c78b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#ga396e74d40e771e25a617d88f08c0c78b">Cy_CSDADC_UnRegisterCallback</a> (<a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *context)</td></tr>
<tr class="memdesc:ga396e74d40e771e25a617d88f08c0c78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unregisters the CSDADC middleware callback.  <a href="#ga396e74d40e771e25a617d88f08c0c78b">More...</a><br /></td></tr>
<tr class="separator:ga396e74d40e771e25a617d88f08c0c78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fe1d5b92fcbbb85230cce544818ce59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#ga2fe1d5b92fcbbb85230cce544818ce59">Cy_CSDADC_StartConvert</a> (<a class="el" href="group__group__csdadc__enums.html#gaa708440f81ca9ab9606919c8a2b55f7b">cy_en_csdadc_conversion_mode_t</a> mode, uint32_t chMask, <a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *context)</td></tr>
<tr class="memdesc:ga2fe1d5b92fcbbb85230cce544818ce59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates an analog-to-digital conversion.  <a href="#ga2fe1d5b92fcbbb85230cce544818ce59">More...</a><br /></td></tr>
<tr class="separator:ga2fe1d5b92fcbbb85230cce544818ce59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c9ffe0845b88cd0a9a773fd1244fcd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#ga8c9ffe0845b88cd0a9a773fd1244fcd5">Cy_CSDADC_StopConvert</a> (<a class="el" href="group__group__csdadc__enums.html#gad199a168031de6437292f791f0cdf2de">cy_en_csdadc_stop_mode_t</a> stopMode, <a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *context)</td></tr>
<tr class="memdesc:ga8c9ffe0845b88cd0a9a773fd1244fcd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function stops conversions in the continuous mode.  <a href="#ga8c9ffe0845b88cd0a9a773fd1244fcd5">More...</a><br /></td></tr>
<tr class="separator:ga8c9ffe0845b88cd0a9a773fd1244fcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb93b3cee2724658cd14d603569cbba6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#gabb93b3cee2724658cd14d603569cbba6">Cy_CSDADC_IsEndConversion</a> (const <a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *context)</td></tr>
<tr class="memdesc:gabb93b3cee2724658cd14d603569cbba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns the status of the CSDADC's operation.  <a href="#gabb93b3cee2724658cd14d603569cbba6">More...</a><br /></td></tr>
<tr class="separator:gabb93b3cee2724658cd14d603569cbba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga984982a9e928f7380555ee375384915a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#ga984982a9e928f7380555ee375384915a">Cy_CSDADC_GetConversionStatus</a> (const <a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *context)</td></tr>
<tr class="memdesc:ga984982a9e928f7380555ee375384915a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function returns a current CSDADC conversion status.  <a href="#ga984982a9e928f7380555ee375384915a">More...</a><br /></td></tr>
<tr class="separator:ga984982a9e928f7380555ee375384915a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d96acbd1f2eae47d4bd97e41e0a3b7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#ga2d96acbd1f2eae47d4bd97e41e0a3b7a">Cy_CSDADC_Calibrate</a> (<a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *context)</td></tr>
<tr class="memdesc:ga2d96acbd1f2eae47d4bd97e41e0a3b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs calibration of the CSDADC.  <a href="#ga2d96acbd1f2eae47d4bd97e41e0a3b7a">More...</a><br /></td></tr>
<tr class="separator:ga2d96acbd1f2eae47d4bd97e41e0a3b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa9c2a4610c5f2e242c1c01c79511560"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#gafa9c2a4610c5f2e242c1c01c79511560">Cy_CSDADC_Wakeup</a> (const <a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *context)</td></tr>
<tr class="memdesc:gafa9c2a4610c5f2e242c1c01c79511560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resumes the middleware after CPU / System Deep Sleep.  <a href="#gafa9c2a4610c5f2e242c1c01c79511560">More...</a><br /></td></tr>
<tr class="separator:gafa9c2a4610c5f2e242c1c01c79511560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a2d7cf6f3e1c4ce0da1512480dc9c8"><td class="memItemLeft" align="right" valign="top">cy_en_syspm_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#gae5a2d7cf6f3e1c4ce0da1512480dc9c8">Cy_CSDADC_DeepSleepCallback</a> (cy_stc_syspm_callback_params_t *callbackParams, cy_en_syspm_callback_mode_t mode)</td></tr>
<tr class="memdesc:gae5a2d7cf6f3e1c4ce0da1512480dc9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles CPU active to CPU / System Deep Sleep power mode transitions for the CSDADC middleware.  <a href="#gae5a2d7cf6f3e1c4ce0da1512480dc9c8">More...</a><br /></td></tr>
<tr class="separator:gae5a2d7cf6f3e1c4ce0da1512480dc9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac34d548ef9dd0d65c874abff00995cab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#gac34d548ef9dd0d65c874abff00995cab">Cy_CSDADC_Save</a> (<a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *context)</td></tr>
<tr class="memdesc:gac34d548ef9dd0d65c874abff00995cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the state of the CSDADC MW so the functionality can be restored using the Cy_CSDACD_Restore() function.  <a href="#gac34d548ef9dd0d65c874abff00995cab">More...</a><br /></td></tr>
<tr class="separator:gac34d548ef9dd0d65c874abff00995cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63d187dca4825b702bcdb5ff73a7aef7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#ga63d187dca4825b702bcdb5ff73a7aef7">Cy_CSDADC_Restore</a> (<a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *context)</td></tr>
<tr class="memdesc:ga63d187dca4825b702bcdb5ff73a7aef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resumes the middleware operation if the <a class="el" href="group__group__csdadc__functions.html#gac34d548ef9dd0d65c874abff00995cab" title="Saves the state of the CSDADC MW so the functionality can be restored using the Cy_CSDACD_Restore() f...">Cy_CSDADC_Save()</a> function was called previously.  <a href="#ga63d187dca4825b702bcdb5ff73a7aef7">More...</a><br /></td></tr>
<tr class="separator:ga63d187dca4825b702bcdb5ff73a7aef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91a0b92cb74fe36d71fab6652b5ec3e1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#ga91a0b92cb74fe36d71fab6652b5ec3e1">Cy_CSDADC_GetResult</a> (uint32_t chId, const <a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *context)</td></tr>
<tr class="memdesc:ga91a0b92cb74fe36d71fab6652b5ec3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the most recent result of a specified channel as an ADC code.  <a href="#ga91a0b92cb74fe36d71fab6652b5ec3e1">More...</a><br /></td></tr>
<tr class="separator:ga91a0b92cb74fe36d71fab6652b5ec3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f07b8602ab61912a1f3424d5a864c0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#gac7f07b8602ab61912a1f3424d5a864c0">Cy_CSDADC_GetResultVoltage</a> (uint32_t chId, const <a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *context)</td></tr>
<tr class="memdesc:gac7f07b8602ab61912a1f3424d5a864c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the the most recent result of a specified channel in millivolts.  <a href="#gac7f07b8602ab61912a1f3424d5a864c0">More...</a><br /></td></tr>
<tr class="separator:gac7f07b8602ab61912a1f3424d5a864c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b317890c0856684420555cd004840a6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#ga4b317890c0856684420555cd004840a6">Cy_CSDADC_MeasureVdda</a> (<a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *context)</td></tr>
<tr class="memdesc:ga4b317890c0856684420555cd004840a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function measures a VDDA voltage and returns the result in millivolts.  <a href="#ga4b317890c0856684420555cd004840a6">More...</a><br /></td></tr>
<tr class="separator:ga4b317890c0856684420555cd004840a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc24d882499442ebd3209703c087fc1c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#gacc24d882499442ebd3209703c087fc1c">Cy_CSDADC_MeasureAMuxB</a> (<a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *context)</td></tr>
<tr class="memdesc:gacc24d882499442ebd3209703c087fc1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function measures an AMUX-B voltage and returns the result in millivolts.  <a href="#gacc24d882499442ebd3209703c087fc1c">More...</a><br /></td></tr>
<tr class="separator:gacc24d882499442ebd3209703c087fc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga514703b9e2da7cc3adf497198558e9b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__csdadc__functions.html#ga514703b9e2da7cc3adf497198558e9b0">Cy_CSDADC_InterruptHandler</a> (const CSD_Type *base, void *CSDADC_Context)</td></tr>
<tr class="memdesc:ga514703b9e2da7cc3adf497198558e9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the interrupt service routine for the CSDADC middleware.  <a href="#ga514703b9e2da7cc3adf497198558e9b0">More...</a><br /></td></tr>
<tr class="separator:ga514703b9e2da7cc3adf497198558e9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga539700892c4ce6ca9c0d076a53a796a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga539700892c4ce6ca9c0d076a53a796a9">&#9670;&nbsp;</a></span>Cy_CSDADC_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a> Cy_CSDADC_Init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__csdadc__config__t.html">cy_stc_csdadc_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Captures the CSD HW block and configures it to the default state, is called by the application program prior to calling any other function of the middleware. </p>
<p>The function:</p><ul>
<li>verifies input parameters</li>
<li>copies the configuration structure to the context structure</li>
<li>disconnects all input channels</li>
<li>verifies the CSD HW block state</li>
<li>locks the CSD HW block</li>
<li>writes the default configuration to the CSD HW block</li>
<li>configures the CSDADC middleware to the default state.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The pointer to the CSDADC configuration structure.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CSDADC context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns the status of its operation.<ul>
<li>CY_CSDADC_SUCCESS - The function performed successfully.</li>
<li>CY_CSDADC_HW_LOCKED - The CSD HW block is already in use by another CSD function. The CSDADC cannot be initialized right now. The user waits until the CSD HW block passes to the idle state.</li>
<li>CY_CSDADC_BAD_PARAM - The context pointer is NULL. The function was not performed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Captures the CSD HW block and initialize it to the default state. */</span></div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#ga539700892c4ce6ca9c0d076a53a796a9">Cy_CSDADC_Init</a>(&amp;CSDADC_csdadc_config, &amp;cy_csdadc_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the CSDADC interrupt */</span></div><div class="line">    Cy_SysInt_Init(&amp;CSDADC_ISR_cfg, &amp;CSDADC_Interrupt);</div><div class="line">    NVIC_ClearPendingIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the CSDADC  firmware modules. */</span></div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#gace0ef0fd816a147c2821877644da81b7">Cy_CSDADC_Enable</a>(&amp;cy_csdadc_context);</div><div class="line"></div></div><!-- fragment --><p>The 'cy_csdadc_context' variable used as the parameter of the <a class="el" href="group__group__csdadc__functions.html#ga539700892c4ce6ca9c0d076a53a796a9" title="Captures the CSD HW block and configures it to the default state, is called by the application progra...">Cy_CSDADC_Init()</a> and <a class="el" href="group__group__csdadc__functions.html#gace0ef0fd816a147c2821877644da81b7" title="Initializes the CSDADC firmware modules. ">Cy_CSDADC_Enable()</a> functions is declared on the application layer according to the example below:<br />
 </p><div class="fragment"><div class="line"><span class="comment">/* CSDADC context declaration */</span></div><div class="line"><a class="code" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> cy_csdadc_context;</div></div><!-- fragment --><p>The 'CSD_csdadc_config' variable used as the parameter of the <a class="el" href="group__group__csdadc__functions.html#ga539700892c4ce6ca9c0d076a53a796a9" title="Captures the CSD HW block and configures it to the default state, is called by the application progra...">Cy_CSDADC_Init()</a> function is declared in the cycfg_capsense.h file if the Device Configurator tool is used. Refer to the <a class="el" href="index.html#group_csdadc_configuration">Configuration Considerations</a> section for details. The 'CSDADC_csdadc_config' variable is declared and initialized on the application layer if the third party IDE is used for development.</p>
<p>The CSDADC_ISR_cfg variable is declared by the application program according to the examples below:<br />
 For CM0+ core: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">const</span> cy_stc_sysint_t CSDADC_ISR_cfg =</div><div class="line">{</div><div class="line">    .intrSrc = NvicMux2_IRQn,       <span class="comment">/* CM0+ interrupt is NVIC #2 */</span></div><div class="line">    .cm0pSrc = csd_interrupt_IRQn,  <span class="comment">/* Source of NVIC #2 is the CSD interrupt */</span></div><div class="line">    .intrPriority = 3u,             <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p> For CM4 core: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">const</span> cy_stc_sysint_t CSDADC_ISR_cfg =</div><div class="line">{</div><div class="line">    .intrSrc = csd_interrupt_IRQn,  <span class="comment">/* Interrupt source is the CSD interrupt */</span></div><div class="line">    .intrPriority = 7u,             <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p> The CSDADC interrupt handler is declared by the application program according to the example below: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> CSDADC_Interrupt(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#ga514703b9e2da7cc3adf497198558e9b0">Cy_CSDADC_InterruptHandler</a>(CSDADC_HW, &amp;cy_csdadc_context);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> The CSDADC_HW is the pointer to the base register address of the CSD HW block. A macro for the pointer is in the cycfg_peripherals.h file defined as &lt;Csd_Personality_Name&gt;_HW. If no name is specified, the default name is used csd_&lt;Block_Number&gt;_csd_&lt;Block_Number&gt;_HW. </p>

</div>
</div>
<a id="gace0ef0fd816a147c2821877644da81b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace0ef0fd816a147c2821877644da81b7">&#9670;&nbsp;</a></span>Cy_CSDADC_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a> Cy_CSDADC_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the CSDADC firmware modules. </p>
<p>The <a class="el" href="group__group__csdadc__functions.html#ga539700892c4ce6ca9c0d076a53a796a9" title="Captures the CSD HW block and configures it to the default state, is called by the application progra...">Cy_CSDADC_Init()</a> function is to be called and the CSD HW block interrupt is to be configured prior to calling this function. The following steps are performed for proper CSDADC initialization:</p><ul>
<li>Capture the CSD HW block and initialize it to the default state.</li>
<li>Initialize the CSDADC interrupt.</li>
<li>Initialize the CSDADC firmware modules.</li>
</ul>
<p>This function is called by the application program prior to calling any other function of the middleware. The function:</p><ul>
<li>Configures the CSD HW block to perform CSDADC conversions</li>
<li>Calibrates the CSDADC for an accurate measurement</li>
</ul>
<p>Any subsequent call of this function repeats an initialization process except for the data structure initialization. Therefore, changing the middleware configuration from the application program is possible. Do this by writing registers to the data structure and calling this function again. This is also done inside the Cy_CSDACD_WriteConfig() function, when configuration must be updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CSDADC context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the initialization process. If CY_RET_SUCCESS is not received, some of the initialization fails.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Captures the CSD HW block and initialize it to the default state. */</span></div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#ga539700892c4ce6ca9c0d076a53a796a9">Cy_CSDADC_Init</a>(&amp;CSDADC_csdadc_config, &amp;cy_csdadc_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the CSDADC interrupt */</span></div><div class="line">    Cy_SysInt_Init(&amp;CSDADC_ISR_cfg, &amp;CSDADC_Interrupt);</div><div class="line">    NVIC_ClearPendingIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the CSDADC  firmware modules. */</span></div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#gace0ef0fd816a147c2821877644da81b7">Cy_CSDADC_Enable</a>(&amp;cy_csdadc_context);</div><div class="line"></div></div><!-- fragment --><p>The 'cy_csdadc_context' variable used as the parameter of the <a class="el" href="group__group__csdadc__functions.html#ga539700892c4ce6ca9c0d076a53a796a9" title="Captures the CSD HW block and configures it to the default state, is called by the application progra...">Cy_CSDADC_Init()</a> and <a class="el" href="group__group__csdadc__functions.html#gace0ef0fd816a147c2821877644da81b7" title="Initializes the CSDADC firmware modules. ">Cy_CSDADC_Enable()</a> functions is declared on the application layer according to the examples below:<br />
 </p><div class="fragment"><div class="line"><span class="comment">/* CSDADC context declaration */</span></div><div class="line"><a class="code" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> cy_csdadc_context;</div></div><!-- fragment --><p>The 'CSD_csdadc_config' variable used as the parameter of the <a class="el" href="group__group__csdadc__functions.html#ga539700892c4ce6ca9c0d076a53a796a9" title="Captures the CSD HW block and configures it to the default state, is called by the application progra...">Cy_CSDADC_Init()</a> function is declared in the cycfg_capsense.h file if the Device Configurator tool is used. Refer to the <a class="el" href="index.html#group_csdadc_configuration">Configuration Considerations</a> section for details.</p>
<p>The CSDADC_ISR_cfg variable should be declared by the application program according to the examples below:<br />
 For CM0+ core: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">const</span> cy_stc_sysint_t CSDADC_ISR_cfg =</div><div class="line">{</div><div class="line">    .intrSrc = NvicMux2_IRQn,       <span class="comment">/* CM0+ interrupt is NVIC #2 */</span></div><div class="line">    .cm0pSrc = csd_interrupt_IRQn,  <span class="comment">/* Source of NVIC #2 is the CSD interrupt */</span></div><div class="line">    .intrPriority = 3u,             <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p> For CM4 core: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">const</span> cy_stc_sysint_t CSDADC_ISR_cfg =</div><div class="line">{</div><div class="line">    .intrSrc = csd_interrupt_IRQn,  <span class="comment">/* Interrupt source is the CSD interrupt */</span></div><div class="line">    .intrPriority = 7u,             <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p> The CSDADC interrupt handler is declared by the application program according to the example below: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> CSDADC_Interrupt(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#ga514703b9e2da7cc3adf497198558e9b0">Cy_CSDADC_InterruptHandler</a>(CSDADC_HW, &amp;cy_csdadc_context);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> The CSDADC_HW is the pointer to the base register address of the CSD HW block. A macro for the pointer is in the cycfg_peripherals.h file defined as &lt;Csd_Personality_Name&gt;_HW. If no name specified, the default name is used csd_&lt;Block_Number&gt;_csd_&lt;Block_Number&gt;_HW. </p>

</div>
</div>
<a id="gaf4df6d98c1998f7e88f41fc4277c61c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4df6d98c1998f7e88f41fc4277c61c0">&#9670;&nbsp;</a></span>Cy_CSDADC_DeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a> Cy_CSDADC_DeInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the middleware operation and releases the CSD HW block. </p>
<p>No input voltage conversion can be executed when the middleware is stopped. This function should be called only when no conversion is in progress. I.e. <a class="el" href="group__group__csdadc__functions.html#gabb93b3cee2724658cd14d603569cbba6" title="The function returns the status of the CSDADC&#39;s operation. ">Cy_CSDADC_IsEndConversion()</a> returns a non-busy status.</p>
<p>After it is stopped, the CSD HW block may be reconfigured by the application program or other middleware for any other use.</p>
<p>When the middleware operation is stopped by the <a class="el" href="group__group__csdadc__functions.html#gaf4df6d98c1998f7e88f41fc4277c61c0" title="Stops the middleware operation and releases the CSD HW block. ">Cy_CSDADC_DeInit()</a> function, a subsequent call of the <a class="el" href="group__group__csdadc__functions.html#ga539700892c4ce6ca9c0d076a53a796a9" title="Captures the CSD HW block and configures it to the default state, is called by the application progra...">Cy_CSDADC_Init()</a> function repeats the initialization process. Calling the <a class="el" href="group__group__csdadc__functions.html#gace0ef0fd816a147c2821877644da81b7" title="Initializes the CSDADC firmware modules. ">Cy_CSDADC_Enable()</a> function is not needed a second time. However, to implement the time-multiplexed mode (sharing the CSD HW Block between multiple middleware), the <a class="el" href="group__group__csdadc__functions.html#gac34d548ef9dd0d65c874abff00995cab" title="Saves the state of the CSDADC MW so the functionality can be restored using the Cy_CSDACD_Restore() f...">Cy_CSDADC_Save()</a>/Cy_CSDADC_Restore() functions should be used instead of <a class="el" href="group__group__csdadc__functions.html#gaf4df6d98c1998f7e88f41fc4277c61c0" title="Stops the middleware operation and releases the CSD HW block. ">Cy_CSDADC_DeInit()</a>/Cy_CSDADC_Init() functions.</p>
<p>Besides releasing the CSD HW block, this function also configures all input channels to the default state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CSDADC context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns the status of its operation.<ul>
<li>CY_CSDADC_SUCCESS - The function performed successfully.</li>
<li>CY_CSDADC_HW_LOCKED - The CSD HW block is busy with ADC conversion. The CSDADC can't be de-initialized right now. The user should wait until the CSD HW block passes to the idle state or use <a class="el" href="group__group__csdadc__functions.html#ga8c9ffe0845b88cd0a9a773fd1244fcd5" title="The function stops conversions in the continuous mode. ">Cy_CSDADC_StopConvert()</a>.</li>
<li>CY_CSDADC_BAD_PARAM - A context pointer is equal to NULL. The function was not performed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1e9f532bc47f4444a10d67fe0cea56cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e9f532bc47f4444a10d67fe0cea56cd">&#9670;&nbsp;</a></span>Cy_CSDADC_WriteConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a> Cy_CSDADC_WriteConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__csdadc__config__t.html">cy_stc_csdadc_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the CSDADC middleware with the desired configuration. </p>
<p>This function sets the desired CSDADC middleware configuration. The function performs the following:</p><ul>
<li>Verifies input parameters. If any of them is equal to NULL, the function does not perform further operations</li>
<li>Initializes the CSDADC context structure in the accordance with the specified configuration</li>
<li>Initializes the CSD HW block registers with data, passed through the specified configuration</li>
<li>Disconnects inputs and sets the CSD HW block to the default state for CSDADC operations</li>
<li>Enables CSDADC operations like the <a class="el" href="group__group__csdadc__functions.html#gace0ef0fd816a147c2821877644da81b7" title="Initializes the CSDADC firmware modules. ">Cy_CSDADC_Enable()</a> function. To start a conversion, the user should call the <a class="el" href="group__group__csdadc__functions.html#ga2fe1d5b92fcbbb85230cce544818ce59" title="Initiates an analog-to-digital conversion. ">Cy_CSDADC_StartConvert()</a> function.</li>
<li>Returns a status code regarding the function execution result</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>This function must be called only in the CSD HW block idle state. A call of this function during a conversion will yield an unpredictable CSD HW block behavior.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function as the <a class="el" href="group__group__csdadc__functions.html#gace0ef0fd816a147c2821877644da81b7" title="Initializes the CSDADC firmware modules. ">Cy_CSDADC_Enable()</a> function can be called only after the CSDADC middleware initialization. To do this, use the <a class="el" href="group__group__csdadc__functions.html#ga539700892c4ce6ca9c0d076a53a796a9" title="Captures the CSD HW block and configures it to the default state, is called by the application progra...">Cy_CSDADC_Init()</a> function and the CSDADC interrupt enabling as it is shown in the code example for the <a class="el" href="group__group__csdadc__functions.html#gace0ef0fd816a147c2821877644da81b7" title="Initializes the CSDADC firmware modules. ">Cy_CSDADC_Enable()</a> function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>The pointer to the CSDADC configuration structure.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CSDADC context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns the status of its operation.<ul>
<li>CY_CSDADC_SUCCESS - The function performed successfully.</li>
<li>CY_CSDADC_BAD_PARAM - A context pointer or config pointer is equal to NULL. The function was not performed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac6088c5e8f20c4a1e46553fd918b4c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6088c5e8f20c4a1e46553fd918b4c9e">&#9670;&nbsp;</a></span>Cy_CSDADC_RegisterCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a> Cy_CSDADC_RegisterCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__csdadc__data__structures.html#gae57e5fc50d39777f67c3cb8d9c176315">cy_csdadc_callback_t</a>&#160;</td>
          <td class="paramname"><em>callbackFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a callback function, which notifies that a callback event occurred in the CSDADC middleware. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackFunction</td><td>The pointer to the callback function.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CSDADC context structure <a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns the status of its operation.<ul>
<li>CY_CSDADC_SUCCESS - The processing performed successfully.</li>
<li>CY_CSDADC_BAD_PARAM - The input parameter is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga396e74d40e771e25a617d88f08c0c78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga396e74d40e771e25a617d88f08c0c78b">&#9670;&nbsp;</a></span>Cy_CSDADC_UnRegisterCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a> Cy_CSDADC_UnRegisterCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function unregisters the CSDADC middleware callback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CSDADC context structure <a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns the status of its operation.<ul>
<li>CY_CSDADC_SUCCESS - The processing performed successfully.</li>
<li>CY_CSDADC_BAD_PARAM - The input parameter is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2fe1d5b92fcbbb85230cce544818ce59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fe1d5b92fcbbb85230cce544818ce59">&#9670;&nbsp;</a></span>Cy_CSDADC_StartConvert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a> Cy_CSDADC_StartConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__csdadc__enums.html#gaa708440f81ca9ab9606919c8a2b55f7b">cy_en_csdadc_conversion_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates an analog-to-digital conversion. </p>
<p>Initializes the CSD HW block to perform an analog-to-digital conversion on input channels specified by chMask. This is a non-blocking function. It initiates conversion only on the first input channel and does not wait for the conversion to complete. The conversion on subsequent channels are initiated by the interrupt service routine of the CSDADC middleware. Therefore, the <a class="el" href="group__group__csdadc__functions.html#gabb93b3cee2724658cd14d603569cbba6" title="The function returns the status of the CSDADC&#39;s operation. ">Cy_CSDADC_IsEndConversion()</a> function must be used to check the status of conversion to ensure the previously initiated conversion is complete prior to initiating other tasks. These include: reading the ADC result, initiation of a new conversion on the same or a different channel, or calibration or stopping a CSDADC conversion.</p>
<p>In Single-shot mode, the CSDADC middleware performs one conversion on all channels specified by the chMask argument and stops. The <a class="el" href="group__group__csdadc__functions.html#gabb93b3cee2724658cd14d603569cbba6" title="The function returns the status of the CSDADC&#39;s operation. ">Cy_CSDADC_IsEndConversion()</a> function returns the CY_CSDADC_SUCCESS status after conversion on all channels completes. Otherwise, it returns the CY_CSDADC_HW_BUSY state. To get information on the latest conversion, use the <a class="el" href="group__group__csdadc__functions.html#ga984982a9e928f7380555ee375384915a" title="The function returns a current CSDADC conversion status. ">Cy_CSDADC_GetConversionStatus()</a> function.</p>
<p>In Continuous mode, this function continuously initiates conversions on channels specified by chMask (i.e. once a conversion is completed on all channels specified by chMask, the CSDADC MW initiates a next set of conversions). The <a class="el" href="group__group__csdadc__functions.html#gabb93b3cee2724658cd14d603569cbba6" title="The function returns the status of the CSDADC&#39;s operation. ">Cy_CSDADC_IsEndConversion()</a> function always returns the CY_CSDADC_HW_BUSY status. To get information on the latest conversion, use the <a class="el" href="group__group__csdadc__functions.html#ga984982a9e928f7380555ee375384915a" title="The function returns a current CSDADC conversion status. ">Cy_CSDADC_GetConversionStatus()</a> functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The desired mode of conversion:<ul>
<li>CY_CSDADC_SINGLE_SHOT - Only one conversion cycle of all chosen channels.</li>
<li>CY_CSDADC_CONTINUOUS - Continuous mode.</li>
</ul>
</td></tr>
    <tr><td class="paramname">chMask</td><td>The bit mask with set bits of specified channels to convert.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CSDADC middleware context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns the status of its operation.<ul>
<li>CY_CSDADC_SUCCESS - A conversion is started.</li>
<li>CY_CSDADC_HW_BUSY - A conversion is not started. A previously initiated conversion is in progress or the CSD HW block is in use by another application.</li>
<li>CY_CSDADC_BAD_PARAM - A conversion is not started. An invalid mode value or chMask is 0 or the context pointer is NULL.</li>
<li>CY_CSDADC_NOT_INITIALIZED - CSDADC to be initialized by using the <a class="el" href="group__group__csdadc__functions.html#ga539700892c4ce6ca9c0d076a53a796a9" title="Captures the CSD HW block and configures it to the default state, is called by the application progra...">Cy_CSDADC_Init()</a> and <a class="el" href="group__group__csdadc__functions.html#gace0ef0fd816a147c2821877644da81b7" title="Initializes the CSDADC firmware modules. ">Cy_CSDADC_Enable()</a> functions.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of the conversion executing in Single-shot mode: </p><div class="fragment"><div class="line">    uint32_t ch0Result;</div><div class="line">    uint32_t ch1Result;</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* The mask to enable conversion on Channel-0 and Channel-1. */</span></div><div class="line">    uint32_t channelsMask = 0x03u;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__csdadc__enums.html#gga2fb51073513c86f28616c29901c55a40a18e1e8f2c080c1697eaf0de8757a2ae4">CY_CSDADC_SUCCESS</a> == <a class="code" href="group__group__csdadc__functions.html#ga2fe1d5b92fcbbb85230cce544818ce59">Cy_CSDADC_StartConvert</a>(<a class="code" href="group__group__csdadc__enums.html#ggaa708440f81ca9ab9606919c8a2b55f7ba68c510fb301d723422dd6ea2fbed7f93">CY_CSDADC_SINGLE_SHOT</a>, channelsMask, &amp;cy_csdadc_context))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">while</span> (<a class="code" href="group__group__csdadc__enums.html#gga2fb51073513c86f28616c29901c55a40a18e1e8f2c080c1697eaf0de8757a2ae4">CY_CSDADC_SUCCESS</a> != <a class="code" href="group__group__csdadc__functions.html#gabb93b3cee2724658cd14d603569cbba6">Cy_CSDADC_IsEndConversion</a>(&amp;cy_csdadc_context))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Waits for the end of conversions. */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Stores the Channel-0 measurement result to the ch0Result variable. */</span></div><div class="line">        ch0Result = <a class="code" href="group__group__csdadc__functions.html#gac7f07b8602ab61912a1f3424d5a864c0">Cy_CSDADC_GetResultVoltage</a>(0u, &amp;cy_csdadc_context);</div><div class="line">        <span class="comment">/* Stores  the Channel-1 measurement result to the ch1Result variable. */</span></div><div class="line">        ch1Result = <a class="code" href="group__group__csdadc__functions.html#gac7f07b8602ab61912a1f3424d5a864c0">Cy_CSDADC_GetResultVoltage</a>(1u, &amp;cy_csdadc_context);</div><div class="line">    }</div></div><!-- fragment --><p> An example of the conversion executing in Continuous mode: </p><div class="fragment"><div class="line">    uint32_t ch0Result;</div><div class="line">    uint32_t ch1Result;</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* The mask to enable conversion on Channel-0 and Channel-1. */</span></div><div class="line">    uint32_t channelsMask = 0x03u;</div><div class="line"></div><div class="line">    <a class="code" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a> retVal;</div><div class="line"></div><div class="line">    uint32_t curConvNumber = 0u;</div><div class="line">    uint32_t prevConvNumber = 0u;</div><div class="line"></div><div class="line">    <span class="comment">/* Starts conversion in Continuous mode. */</span></div><div class="line">    retVal = <a class="code" href="group__group__csdadc__functions.html#ga2fe1d5b92fcbbb85230cce544818ce59">Cy_CSDADC_StartConvert</a>(<a class="code" href="group__group__csdadc__enums.html#ggaa708440f81ca9ab9606919c8a2b55f7bae0c3fb2f8053bf71a9fb27142c11a45d">CY_CSDADC_CONTINUOUS</a>, channelsMask, &amp;cy_csdadc_context);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    * Checks the execution status of the Cy_CSDADC_StartConvert()routine. Handles the failing status</span></div><div class="line"><span class="comment">    * if the conversion is not started successfully.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__csdadc__enums.html#gga2fb51073513c86f28616c29901c55a40a18e1e8f2c080c1697eaf0de8757a2ae4">CY_CSDADC_SUCCESS</a> != retVal)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Places the handling code here. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (;;)</div><div class="line">    {</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">        * Checks if the conversion is completed on all of the configured channels.</span></div><div class="line"><span class="comment">        * The Cy_CSDADC_GetConversionStatus() function returns a combination of</span></div><div class="line"><span class="comment">        * a conversion number and channel number.</span></div><div class="line"><span class="comment">        * Bit[0-26] (CY_CSDADC_COUNTER_CYCLE_MASK) is the current cycle number in</span></div><div class="line"><span class="comment">        * Continuous mode. This counter increment indicates that the current</span></div><div class="line"><span class="comment">        * conversion is completed on all of the configured channels.</span></div><div class="line"><span class="comment">        */</span></div><div class="line">        curConvNumber = <a class="code" href="group__group__csdadc__functions.html#ga984982a9e928f7380555ee375384915a">Cy_CSDADC_GetConversionStatus</a>(&amp;cy_csdadc_context);</div><div class="line">        curConvNumber &amp;= <a class="code" href="group__group__csdadc__macros.html#ga042e47d932d202c2b48aaaa76fd7508a">CY_CSDADC_COUNTER_CYCLE_MASK</a>;</div><div class="line">        <span class="keywordflow">if</span>(curConvNumber != prevConvNumber)</div><div class="line">        {</div><div class="line">            prevConvNumber = curConvNumber;</div><div class="line"></div><div class="line">            <span class="comment">/* Stores the Channel-0 measurement result to the ch0Result variable. */</span></div><div class="line">            ch0Result = <a class="code" href="group__group__csdadc__functions.html#gac7f07b8602ab61912a1f3424d5a864c0">Cy_CSDADC_GetResultVoltage</a>(0u, &amp;cy_csdadc_context);</div><div class="line">            <span class="comment">/* Stores the Channel-1 measurement result to the ch1Result variable. */</span></div><div class="line">            ch1Result = <a class="code" href="group__group__csdadc__functions.html#gac7f07b8602ab61912a1f3424d5a864c0">Cy_CSDADC_GetResultVoltage</a>(1u, &amp;cy_csdadc_context);</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment -->
</div>
</div>
<a id="ga8c9ffe0845b88cd0a9a773fd1244fcd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c9ffe0845b88cd0a9a773fd1244fcd5">&#9670;&nbsp;</a></span>Cy_CSDADC_StopConvert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a> Cy_CSDADC_StopConvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__csdadc__enums.html#gad199a168031de6437292f791f0cdf2de">cy_en_csdadc_stop_mode_t</a>&#160;</td>
          <td class="paramname"><em>stopMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function stops conversions in the continuous mode. </p>
<p>This function can be used to stop CSDADC conversions in continuous mode. The ADC can be stopped instantly by ignoring current and all future conversions in the queue. Or it can be stopped after the current conversion on an input channel is completed but ignore future conversions in the queue. Or it can be stopped after the current conversion cycle (i.e. one set of conversion on all enabled inputs) is completed and ignore conversion cycles in the queue.</p>
<p>The ADC status should be checked using the <a class="el" href="group__group__csdadc__functions.html#gabb93b3cee2724658cd14d603569cbba6" title="The function returns the status of the CSDADC&#39;s operation. ">Cy_CSDADC_IsEndConversion()</a> function. A new conversion or calibration should be started only if CSDADC is not BUSY.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stopMode</td><td>The desired mode of the stop operation. It can be:<ul>
<li>CY_CSDADC_IMMED_STOP - The CSDADC conversion will be stopped immediately. A last channel conversion may produce an invalid result.</li>
<li>CY_CSDADC_CURRENT_CHAN_STOP - The CSDADC conversion will be stopped after the current channel conversion to be completed.</li>
<li>CY_CSDADC_ENABLED_CHAN_STOP - The CSDADC conversion will be stopped after all the enabled channels conversions to be completed.</li>
</ul>
</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CSDADC middleware context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns the next statuses:<ul>
<li>CY_CSDADC_SUCCESS - Stop operation successful. The CSDADC conversion is stopped in the case of the immediate stop mode or the stop conversion bit in the CSDADC status byte is set to stop conversions after the current channel or all the enabled channels are completed.</li>
<li>CY_CSDADC_BAD_PARAM - An input parameter is bad. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gabb93b3cee2724658cd14d603569cbba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb93b3cee2724658cd14d603569cbba6">&#9670;&nbsp;</a></span>Cy_CSDADC_IsEndConversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a> Cy_CSDADC_IsEndConversion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function returns the status of the CSDADC's operation. </p>
<p>This function is used to ensure the CSDADC is in the idle state prior to initiating a conversion, calibration, or configuration change. Initiating any ADC operation while the CSDADC is in the busy state may produce unexpected results from the ADC.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CSDADC context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns the status of the ADC operation.<ul>
<li>CY_CSDADC_SUCCESS - The ADC is not busy, so a new conversion can be initiated.</li>
<li>CY_CSDADC_HW_BUSY - The previously initiated conversion is in progress.</li>
<li>CY_CSDADC_OVERFLOW - The most recent conversion caused an overflow. The root cause of the overflow may be the previous calibration values being invalid or VDDA and VDDA configuration setting mismatch. Perform a re-calibration or set the appropriate VDDA value to avoid this error condition.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of the <a class="el" href="group__group__csdadc__functions.html#gabb93b3cee2724658cd14d603569cbba6" title="The function returns the status of the CSDADC&#39;s operation. ">Cy_CSDADC_IsEndConversion()</a> function usage: </p><div class="fragment"><div class="line">    uint32_t ch0Result;</div><div class="line">    uint32_t ch1Result;</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* The mask to enable conversion on Channel-0 and Channel-1. */</span></div><div class="line">    uint32_t channelsMask = 0x03u;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__csdadc__enums.html#gga2fb51073513c86f28616c29901c55a40a18e1e8f2c080c1697eaf0de8757a2ae4">CY_CSDADC_SUCCESS</a> == <a class="code" href="group__group__csdadc__functions.html#ga2fe1d5b92fcbbb85230cce544818ce59">Cy_CSDADC_StartConvert</a>(<a class="code" href="group__group__csdadc__enums.html#ggaa708440f81ca9ab9606919c8a2b55f7ba68c510fb301d723422dd6ea2fbed7f93">CY_CSDADC_SINGLE_SHOT</a>, channelsMask, &amp;cy_csdadc_context))</div><div class="line">    {</div><div class="line">        <span class="keywordflow">while</span> (<a class="code" href="group__group__csdadc__enums.html#gga2fb51073513c86f28616c29901c55a40a18e1e8f2c080c1697eaf0de8757a2ae4">CY_CSDADC_SUCCESS</a> != <a class="code" href="group__group__csdadc__functions.html#gabb93b3cee2724658cd14d603569cbba6">Cy_CSDADC_IsEndConversion</a>(&amp;cy_csdadc_context))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Waits for the end of conversions. */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Stores the Channel-0 measurement result to the ch0Result variable. */</span></div><div class="line">        ch0Result = <a class="code" href="group__group__csdadc__functions.html#gac7f07b8602ab61912a1f3424d5a864c0">Cy_CSDADC_GetResultVoltage</a>(0u, &amp;cy_csdadc_context);</div><div class="line">        <span class="comment">/* Stores  the Channel-1 measurement result to the ch1Result variable. */</span></div><div class="line">        ch1Result = <a class="code" href="group__group__csdadc__functions.html#gac7f07b8602ab61912a1f3424d5a864c0">Cy_CSDADC_GetResultVoltage</a>(1u, &amp;cy_csdadc_context);</div><div class="line">    }</div></div><!-- fragment -->
</div>
</div>
<a id="ga984982a9e928f7380555ee375384915a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga984982a9e928f7380555ee375384915a">&#9670;&nbsp;</a></span>Cy_CSDADC_GetConversionStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CSDADC_GetConversionStatus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function returns a current CSDADC conversion status. </p>
<p>In Continuous mode, this function returns a combination of the current channel number and current cycle number. This function can be used to identify whether a cycle of conversion completed or identify the latest input where the conversion completed so a result can be read. In Single-shot mode, only the latest input where a conversion completed is returned. A conversion cycle number is incremented by the CSDADC after each cycle of conversion completes. A channel number is assigned to each input channel. A new start-conversion request resets the conversion cycle number to zero and the channel number to the first enabled channel in the chMask parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CSDADC context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns a combination of the conversion number and channel number.<ul>
<li>Bit[0-26] The current cycle number in Continuous mode. In the single shot mode, it is equal to 0u.</li>
<li>Bit[27-31] A current input channel number inside the current cycle.</li>
<li>If the context parameter is equal to NULL, then the function returns <a class="el" href="group__group__csdadc__macros.html#ga5ef5dc9f8b641bdecb1d91f3cc57874d">CY_CSDADC_COUNTER_BAD_PARAM</a>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of the <a class="el" href="group__group__csdadc__functions.html#ga984982a9e928f7380555ee375384915a" title="The function returns a current CSDADC conversion status. ">Cy_CSDADC_GetConversionStatus()</a> function usage: </p><div class="fragment"><div class="line">    uint32_t ch0Result;</div><div class="line">    uint32_t ch1Result;</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* The mask to enable conversion on Channel-0 and Channel-1. */</span></div><div class="line">    uint32_t channelsMask = 0x03u;</div><div class="line"></div><div class="line">    <a class="code" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a> retVal;</div><div class="line"></div><div class="line">    uint32_t curConvNumber = 0u;</div><div class="line">    uint32_t prevConvNumber = 0u;</div><div class="line"></div><div class="line">    <span class="comment">/* Starts conversion in Continuous mode. */</span></div><div class="line">    retVal = <a class="code" href="group__group__csdadc__functions.html#ga2fe1d5b92fcbbb85230cce544818ce59">Cy_CSDADC_StartConvert</a>(<a class="code" href="group__group__csdadc__enums.html#ggaa708440f81ca9ab9606919c8a2b55f7bae0c3fb2f8053bf71a9fb27142c11a45d">CY_CSDADC_CONTINUOUS</a>, channelsMask, &amp;cy_csdadc_context);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    * Checks the execution status of the Cy_CSDADC_StartConvert()routine. Handles the failing status</span></div><div class="line"><span class="comment">    * if the conversion is not started successfully.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__csdadc__enums.html#gga2fb51073513c86f28616c29901c55a40a18e1e8f2c080c1697eaf0de8757a2ae4">CY_CSDADC_SUCCESS</a> != retVal)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Places the handling code here. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (;;)</div><div class="line">    {</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">        * Checks if the conversion is completed on all of the configured channels.</span></div><div class="line"><span class="comment">        * The Cy_CSDADC_GetConversionStatus() function returns a combination of</span></div><div class="line"><span class="comment">        * a conversion number and channel number.</span></div><div class="line"><span class="comment">        * Bit[0-26] (CY_CSDADC_COUNTER_CYCLE_MASK) is the current cycle number in</span></div><div class="line"><span class="comment">        * Continuous mode. This counter increment indicates that the current</span></div><div class="line"><span class="comment">        * conversion is completed on all of the configured channels.</span></div><div class="line"><span class="comment">        */</span></div><div class="line">        curConvNumber = <a class="code" href="group__group__csdadc__functions.html#ga984982a9e928f7380555ee375384915a">Cy_CSDADC_GetConversionStatus</a>(&amp;cy_csdadc_context);</div><div class="line">        curConvNumber &amp;= <a class="code" href="group__group__csdadc__macros.html#ga042e47d932d202c2b48aaaa76fd7508a">CY_CSDADC_COUNTER_CYCLE_MASK</a>;</div><div class="line">        <span class="keywordflow">if</span>(curConvNumber != prevConvNumber)</div><div class="line">        {</div><div class="line">            prevConvNumber = curConvNumber;</div><div class="line"></div><div class="line">            <span class="comment">/* Stores the Channel-0 measurement result to the ch0Result variable. */</span></div><div class="line">            ch0Result = <a class="code" href="group__group__csdadc__functions.html#gac7f07b8602ab61912a1f3424d5a864c0">Cy_CSDADC_GetResultVoltage</a>(0u, &amp;cy_csdadc_context);</div><div class="line">            <span class="comment">/* Stores the Channel-1 measurement result to the ch1Result variable. */</span></div><div class="line">            ch1Result = <a class="code" href="group__group__csdadc__functions.html#gac7f07b8602ab61912a1f3424d5a864c0">Cy_CSDADC_GetResultVoltage</a>(1u, &amp;cy_csdadc_context);</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment -->
</div>
</div>
<a id="ga2d96acbd1f2eae47d4bd97e41e0a3b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d96acbd1f2eae47d4bd97e41e0a3b7a">&#9670;&nbsp;</a></span>Cy_CSDADC_Calibrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a> Cy_CSDADC_Calibrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs calibration of the CSDADC. </p>
<p>Executes calibration for the CSDADC to identify optimal CSD HW block configuration to produce accurate results. The configuration parameters are dependent on VDDA, VREF, IDAC, and PERI_CLK tolerances, and hence run calibrations periodically (for example every 10 seconds) to compensate for variation in the above mentioned parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CSDADC context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns the status of its operation.<ul>
<li>CY_CSDADC_SUCCESS - The CSD HW block is successfully calibrated for the ADC use.</li>
<li>CY_CSDADC_BAD_PARAM - The context pointer is NULL. A calibration has not been executed.</li>
<li>CY_CSDADC_HW_BUSY - The CSD HW block is already in use by a previously initialized conversion or other function. A calibration has not been executed.</li>
<li>CY_CSDADC_CALIBRATION_FAIL - The operation watchdog is triggered. The calibration was not performed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gafa9c2a4610c5f2e242c1c01c79511560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa9c2a4610c5f2e242c1c01c79511560">&#9670;&nbsp;</a></span>Cy_CSDADC_Wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a> Cy_CSDADC_Wakeup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resumes the middleware after CPU / System Deep Sleep. </p>
<p>This function is used to resume the middleware operation after exiting CPU / System Deep Sleep. After the CSD HW block has been powered off and an extra delay is required to establish correct operation of the CSD HW block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CSDADC context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns the status of its operation.<ul>
<li>CY_CSDADC_SUCCESS - The function performed successfully.</li>
<li>CY_CSDADC_BAD_PARAM - A context pointer is equal to NULL. The function was not performed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae5a2d7cf6f3e1c4ce0da1512480dc9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5a2d7cf6f3e1c4ce0da1512480dc9c8">&#9670;&nbsp;</a></span>Cy_CSDADC_DeepSleepCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_syspm_status_t Cy_CSDADC_DeepSleepCallback </td>
          <td>(</td>
          <td class="paramtype">cy_stc_syspm_callback_params_t *&#160;</td>
          <td class="paramname"><em>callbackParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_en_syspm_callback_mode_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles CPU active to CPU / System Deep Sleep power mode transitions for the CSDADC middleware. </p>
<p>Do not call this function directly from the application program. Instead, use Cy_SysPm_CpuEnterDeepSleep() for CPU active to CPU / System Deep Sleep power mode transitions. </p><dl class="section note"><dt>Note</dt><dd>After the CPU Deep Sleep transition, the device automatically goes to System Deep Sleep if all conditions are fulfilled: another core is in CPU Deep Sleep, all the peripherals are ready to System Deep Sleep, etc. (see details in the device TRM).</dd></dl>
<p>For proper operation of the CSDADC middleware during CPU active to CPU / System Deep Sleep mode transitions, a callback to this function is registered using the Cy_SysPm_RegisterCallback() function with the CY_SYSPM_DEEPSLEEP type. After the callback is registered, this function is called by the Cy_SysPm_CpuEnterDeepSleep() function to prepare the middleware to the device power mode transition.</p>
<p>When this function is called with CY_SYSPM_CHECK_READY as the input, this function returns CY_SYSPM_SUCCESS if no conversion is in progress. Otherwise, CY_SYSPM_FAIL is returned. If the CY_SYSPM_FAIL status is returned, a device cannot change the power mode without completing the current conversion because a transition to CPU / System Deep Sleep during the conversion can disrupt the middleware operation.</p>
<p>For details of the SysPm types and macros, refer to the SysPm section of the PDL documentation <a href="https://www.cypress.com/documentation/technical-reference-manuals/psoc-6-mcu-psoc-63-ble-architecture-technical-reference" title="PDL API Reference">PDL API Reference</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackParams</td><td>Refer to the description of the cy_stc_syspm_callback_params_t type in the Peripheral Driver Library documentation.</td></tr>
    <tr><td class="paramname">mode</td><td>Specifies mode cy_en_syspm_callback_mode_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status cy_en_syspm_status_t of the operation requested by the mode parameter:<ul>
<li>CY_SYSPM_SUCCESS - CPU / System Deep Sleep power mode can be entered.</li>
<li>CY_SYSPM_FAIL - CPU / System Deep Sleep power mode cannot be entered. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac34d548ef9dd0d65c874abff00995cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac34d548ef9dd0d65c874abff00995cab">&#9670;&nbsp;</a></span>Cy_CSDADC_Save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a> Cy_CSDADC_Save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the state of the CSDADC MW so the functionality can be restored using the Cy_CSDACD_Restore() function. </p>
<dl class="section warning"><dt>Warning</dt><dd>The function operates only in the idle state of the CSDADC.</dd></dl>
<p>This function, along with the Cy_CSDACD_Restore() function, is specifically designed for ease of use and supports time multiplexing of the CSD HW block among multiple middleware. When the CSD HW block is shared by two or more middleware, this function can be used to save the current state of the CSD HW block and the CSDADC middleware prior to releasing the CSD HW block for use by other middleware.</p>
<p>This function performs the same tasks as the <a class="el" href="group__group__csdadc__functions.html#gaf4df6d98c1998f7e88f41fc4277c61c0" title="Stops the middleware operation and releases the CSD HW block. ">Cy_CSDADC_DeInit()</a> function and is kept for API consistency among middleware. Use the <a class="el" href="group__group__csdadc__functions.html#gac34d548ef9dd0d65c874abff00995cab" title="Saves the state of the CSDADC MW so the functionality can be restored using the Cy_CSDACD_Restore() f...">Cy_CSDADC_Save()</a>/Cy_CSDADC_Restore() functions to implement Time-multiplexed mode instead of the Cy_CSSADC_DeInit()/Cy_CSDADC_Init() functions for further compatibility. This function:</p><ul>
<li>Checks whether CSDADC is in the idle state. If the CSDADC is busy, the function does nothing. <br />
 In the idle state:<ul>
<li>Releases the CSD HW block</li>
<li>Disconnects channel input pins from analog muxbus B and configures them to the default state.</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CSDADC context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the process. If CY_CSDADC_SUCCESS is not received, the save process fails and a retry may be required.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of sharing the CSD HW block with the CapSense and CSDADC middleware.<br />
 Declares the CapSense_ISR_cfg variable: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">{</div><div class="line">    .intrSrc = csd_interrupt_IRQn, <span class="comment">/* Interrupt source is the CSD interrupt */</span></div><div class="line">    .intrPriority = 7u,            <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p> Declares the CSDADC_ISR_cfg variable: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">const</span> cy_stc_sysint_t CSDADC_ISR_cfg =</div><div class="line">{</div><div class="line">    .intrSrc = csd_interrupt_IRQn,  <span class="comment">/* Interrupt source is the CSD interrupt */</span></div><div class="line">    .intrPriority = 7u,             <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p> Defines the CapSense interrupt handler: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> CapSense_Interrupt(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    Cy_CapSense_InterruptHandler(CSDADC_HW, &amp;cy_capsense_context);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> Defines the CSDADC interrupt handler: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> CSDADC_Interrupt(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#ga514703b9e2da7cc3adf497198558e9b0">Cy_CSDADC_InterruptHandler</a>(CSDADC_HW, &amp;cy_csdadc_context);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> The part of the main.c FW flow: </p><div class="fragment"><div class="line">    <span class="comment">/* ... */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the CapSense MW. */</span></div><div class="line">    Cy_CapSense_Init(&amp;cy_capsense_context);</div><div class="line">    Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;CapSense_Interrupt);</div><div class="line">    NVIC_ClearPendingIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">    Cy_CapSense_Enable(&amp;cy_capsense_context);</div><div class="line">    Cy_CapSense_Save(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the CSDADC MW. */</span></div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#ga539700892c4ce6ca9c0d076a53a796a9">Cy_CSDADC_Init</a>(&amp;CSDADC_csdadc_config, &amp;cy_csdadc_context);</div><div class="line">    Cy_SysInt_Init(&amp;CSDADC_ISR_cfg, &amp;CSDADC_Interrupt);</div><div class="line">    NVIC_ClearPendingIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#gace0ef0fd816a147c2821877644da81b7">Cy_CSDADC_Enable</a>(&amp;cy_csdadc_context);</div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#gac34d548ef9dd0d65c874abff00995cab">Cy_CSDADC_Save</a>(&amp;cy_csdadc_context);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (;;)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Switches to the CapSense MW. */</span></div><div class="line">        Cy_CapSense_Restore(&amp;cy_capsense_context);</div><div class="line">        Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;CapSense_Interrupt);</div><div class="line">        <span class="comment">/* Does the CapSense sensing operation. */</span></div><div class="line">        Cy_CapSense_Save(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">        <span class="comment">/* Switches to the CSDADC MW. */</span></div><div class="line">        <a class="code" href="group__group__csdadc__functions.html#ga63d187dca4825b702bcdb5ff73a7aef7">Cy_CSDADC_Restore</a>(&amp;cy_csdadc_context);</div><div class="line">        Cy_SysInt_Init(&amp;CSDADC_ISR_cfg, &amp;CSDADC_Interrupt);</div><div class="line">        <span class="comment">/* Does the CSDADC measurement operation. */</span></div><div class="line">        <a class="code" href="group__group__csdadc__functions.html#gac34d548ef9dd0d65c874abff00995cab">Cy_CSDADC_Save</a>(&amp;cy_csdadc_context);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* ... */</span></div></div><!-- fragment -->
</div>
</div>
<a id="ga63d187dca4825b702bcdb5ff73a7aef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63d187dca4825b702bcdb5ff73a7aef7">&#9670;&nbsp;</a></span>Cy_CSDADC_Restore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__csdadc__enums.html#ga2fb51073513c86f28616c29901c55a40">cy_en_csdadc_status_t</a> Cy_CSDADC_Restore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resumes the middleware operation if the <a class="el" href="group__group__csdadc__functions.html#gac34d548ef9dd0d65c874abff00995cab" title="Saves the state of the CSDADC MW so the functionality can be restored using the Cy_CSDACD_Restore() f...">Cy_CSDADC_Save()</a> function was called previously. </p>
<p>This function, along with the <a class="el" href="group__group__csdadc__functions.html#gac34d548ef9dd0d65c874abff00995cab" title="Saves the state of the CSDADC MW so the functionality can be restored using the Cy_CSDACD_Restore() f...">Cy_CSDADC_Save()</a> function, is specifically designed for ease of use and supports time multiplexing of the CSD HW block among multiple middleware. When the CSD HW block is shared by two or more middleware, this function can be used to restore the previous state of the CSD HW block and CSDADC middleware saved using the Cy_CSDACD_Save() function. This function performs a sub-set of initialization tasks and is used into the <a class="el" href="group__group__csdadc__functions.html#ga539700892c4ce6ca9c0d076a53a796a9" title="Captures the CSD HW block and configures it to the default state, is called by the application progra...">Cy_CSDADC_Init()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CSDADC middleware context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the resume process. If CY_CSDADC_SUCCESS is not received, the resume process fails and a retry may be required.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of sharing the CSD HW block by CapSense and CSDADC middleware: </p><div class="fragment"><div class="line">    <span class="comment">/* ... */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the CapSense MW. */</span></div><div class="line">    Cy_CapSense_Init(&amp;cy_capsense_context);</div><div class="line">    Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;CapSense_Interrupt);</div><div class="line">    NVIC_ClearPendingIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">    Cy_CapSense_Enable(&amp;cy_capsense_context);</div><div class="line">    Cy_CapSense_Save(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the CSDADC MW. */</span></div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#ga539700892c4ce6ca9c0d076a53a796a9">Cy_CSDADC_Init</a>(&amp;CSDADC_csdadc_config, &amp;cy_csdadc_context);</div><div class="line">    Cy_SysInt_Init(&amp;CSDADC_ISR_cfg, &amp;CSDADC_Interrupt);</div><div class="line">    NVIC_ClearPendingIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#gace0ef0fd816a147c2821877644da81b7">Cy_CSDADC_Enable</a>(&amp;cy_csdadc_context);</div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#gac34d548ef9dd0d65c874abff00995cab">Cy_CSDADC_Save</a>(&amp;cy_csdadc_context);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (;;)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Switches to the CapSense MW. */</span></div><div class="line">        Cy_CapSense_Restore(&amp;cy_capsense_context);</div><div class="line">        Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;CapSense_Interrupt);</div><div class="line">        <span class="comment">/* Does the CapSense sensing operation. */</span></div><div class="line">        Cy_CapSense_Save(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">        <span class="comment">/* Switches to the CSDADC MW. */</span></div><div class="line">        <a class="code" href="group__group__csdadc__functions.html#ga63d187dca4825b702bcdb5ff73a7aef7">Cy_CSDADC_Restore</a>(&amp;cy_csdadc_context);</div><div class="line">        Cy_SysInt_Init(&amp;CSDADC_ISR_cfg, &amp;CSDADC_Interrupt);</div><div class="line">        <span class="comment">/* Does the CSDADC measurement operation. */</span></div><div class="line">        <a class="code" href="group__group__csdadc__functions.html#gac34d548ef9dd0d65c874abff00995cab">Cy_CSDADC_Save</a>(&amp;cy_csdadc_context);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* ... */</span></div></div><!-- fragment -->
</div>
</div>
<a id="ga91a0b92cb74fe36d71fab6652b5ec3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91a0b92cb74fe36d71fab6652b5ec3e1">&#9670;&nbsp;</a></span>Cy_CSDADC_GetResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CSDADC_GetResult </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the most recent result of a specified channel as an ADC code. </p>
<p>The function neither initiates a conversion nor converts the ADC result in millivolts. Instead it returns the most recent conversion result on specified input as an ADC code. The valid range for result is from 0 to 2^ CSDADCresolution - 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chId</td><td>An ID of the input channel to read the most recent result. Acceptable values are between 0 and (chNum - 1).</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CSDADC context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Specifies the CSDADC input channel code result between 0 and 2^resolution - 1. If a channel number is invalid, CY_CSDADC_MEASUREMENT_FAILED is returned because this function returns a number (not a status). </dd></dl>

</div>
</div>
<a id="gac7f07b8602ab61912a1f3424d5a864c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7f07b8602ab61912a1f3424d5a864c0">&#9670;&nbsp;</a></span>Cy_CSDADC_GetResultVoltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CSDADC_GetResultVoltage </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>chId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the the most recent result of a specified channel in millivolts. </p>
<p>The function does not initiate a conversion. Instead it returns the most recent conversion result on specified input in millivolts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chId</td><td>An ID of the input channel to read the most recent result. Acceptable values are between 0 and (chNum - 1).</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CSDADC context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Specifies the CSDADC input channel result in millivolts. If a channel number is invalid or the pointer to the CSDADC context is equal to NULL, <a class="el" href="group__group__csdadc__macros.html#gaea99199de84378b4a5f0223ddf79d680">CY_CSDADC_MEASUREMENT_FAILED</a> is returned. </dd></dl>

</div>
</div>
<a id="ga4b317890c0856684420555cd004840a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b317890c0856684420555cd004840a6">&#9670;&nbsp;</a></span>Cy_CSDADC_MeasureVdda()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CSDADC_MeasureVdda </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function measures a VDDA voltage and returns the result in millivolts. </p>
<p>This function measures supply voltage (VDDA) of device without need of explicitly connecting VDDA to a GPIO input of ADC. This capability can be used to measure battery voltage and/or change VDDA dependent parameters of the ADC during run-time.</p>
<p>The conversion is initiated only if the CSDADC is in IDLE state and a context parameter is not NULL. This function is blocking function, i.e. waits for ADC conversion to be completed prior to returning to caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CSDADC middleware context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns measurement result, VDDA in millivolts. If the pointer to the CSDADC context is equal to NULL or ADC is not in IDLE state, <a class="el" href="group__group__csdadc__macros.html#gaea99199de84378b4a5f0223ddf79d680">CY_CSDADC_MEASUREMENT_FAILED</a> is returned. </dd></dl>

</div>
</div>
<a id="gacc24d882499442ebd3209703c087fc1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc24d882499442ebd3209703c087fc1c">&#9670;&nbsp;</a></span>Cy_CSDADC_MeasureAMuxB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CSDADC_MeasureAMuxB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function measures an AMUX-B voltage and returns the result in millivolts. </p>
<p>This function measures a voltage on AMUX-B without need for explicitly connecting a GPIO input to the CSDADC. This capability can be used to measure an internal voltage connectable to AMUX-B. It is the responsibility of the application program to establish connection between a voltage source and AMUX-B prior to initiating a conversion with this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CSDADC middleware context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns the result of an analog MuxBusB voltage measuring in millivolts. If the pointer to the CSDADC context is equal to NULL or ADC is not in the idle state, CY_CSDADC_MEASUREMENT_FAILED is returned. </dd></dl>

</div>
</div>
<a id="ga514703b9e2da7cc3adf497198558e9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga514703b9e2da7cc3adf497198558e9b0">&#9670;&nbsp;</a></span>Cy_CSDADC_InterruptHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CSDADC_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype">const CSD_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>CSDADC_Context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements the interrupt service routine for the CSDADC middleware. </p>
<p>The CSD HW block generates an interrupt at the end of every conversion or a calculation phase. The CSDADC middleware uses this interrupt to implement a non-blocking conversion method, in which only the first conversion is initiated by the application program and subsequent conversions are initiated in the interrupt service routine as soon as the current one is completed. The above stated interrupt service routine is implemented as a part of the CSDADC middleware.</p>
<p>The CSDADC middleware does not initialize or modify the priority of interrupts. For the middleware operation, the application program must configure the CSD interrupt and assign the interrupt vector to the Cy_CSDACD_InterruptHandler() function. If the CSD HW block is shared by more than one middleware, the CSD interrupt vector is initialized to the interrupt handler function of the middleware that is active in the application program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the base register address of the CSD HW block. A macro for the pointer can be found in cycfg_peripherals.h file defined as &lt;Csd_Personality_Name&gt;_HW. If no name is specified, the default name is used csd_&lt;Block_Number&gt;_csd_&lt;Block_Number&gt;_HW.</td></tr>
    <tr><td class="paramname">CSDADC_Context</td><td>The pointer to the CSDADC context structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd>An example of the ISR initialization:</dd></dl>
<p>The CSDADC_ISR_cfg variable is declared by the application program according to the examples below:<br />
 For CM0+ core: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">const</span> cy_stc_sysint_t CSDADC_ISR_cfg =</div><div class="line">{</div><div class="line">    .intrSrc = NvicMux2_IRQn,       <span class="comment">/* CM0+ interrupt is NVIC #2 */</span></div><div class="line">    .cm0pSrc = csd_interrupt_IRQn,  <span class="comment">/* Source of NVIC #2 is the CSD interrupt */</span></div><div class="line">    .intrPriority = 3u,             <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p> For CM4 core: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">const</span> cy_stc_sysint_t CSDADC_ISR_cfg =</div><div class="line">{</div><div class="line">    .intrSrc = csd_interrupt_IRQn,  <span class="comment">/* Interrupt source is the CSD interrupt */</span></div><div class="line">    .intrPriority = 7u,             <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p> The CSDADC interrupt handler should be declared by the application program according to the example below: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> CSDADC_Interrupt(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#ga514703b9e2da7cc3adf497198558e9b0">Cy_CSDADC_InterruptHandler</a>(CSDADC_HW, &amp;cy_csdadc_context);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> Then, the application program configures and enables the CSD block interrupt between calls of the Cy_CapSense_Init() and Cy_CapSense_Enable() functions: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Captures the CSD HW block and initialize it to the default state. */</span></div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#ga539700892c4ce6ca9c0d076a53a796a9">Cy_CSDADC_Init</a>(&amp;CSDADC_csdadc_config, &amp;cy_csdadc_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the CSDADC interrupt */</span></div><div class="line">    Cy_SysInt_Init(&amp;CSDADC_ISR_cfg, &amp;CSDADC_Interrupt);</div><div class="line">    NVIC_ClearPendingIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the CSDADC  firmware modules. */</span></div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#gace0ef0fd816a147c2821877644da81b7">Cy_CSDADC_Enable</a>(&amp;cy_csdadc_context);</div><div class="line"></div></div><!-- fragment --><p> An example of sharing the CSD HW block by the CapSense and CSDADC middleware.<br />
 Declares the CapSense_ISR_cfg variable: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">{</div><div class="line">    .intrSrc = csd_interrupt_IRQn, <span class="comment">/* Interrupt source is the CSD interrupt */</span></div><div class="line">    .intrPriority = 7u,            <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p> Declares the CSDADC_ISR_cfg variable: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">const</span> cy_stc_sysint_t CSDADC_ISR_cfg =</div><div class="line">{</div><div class="line">    .intrSrc = csd_interrupt_IRQn,  <span class="comment">/* Interrupt source is the CSD interrupt */</span></div><div class="line">    .intrPriority = 7u,             <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p> Defines the CapSense interrupt handler: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> CapSense_Interrupt(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    Cy_CapSense_InterruptHandler(CSDADC_HW, &amp;cy_capsense_context);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> Defines the CSDADC interrupt handler: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> CSDADC_Interrupt(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#ga514703b9e2da7cc3adf497198558e9b0">Cy_CSDADC_InterruptHandler</a>(CSDADC_HW, &amp;cy_csdadc_context);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> The part of the main.c FW flow: </p><div class="fragment"><div class="line">    <span class="comment">/* ... */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the CapSense MW. */</span></div><div class="line">    Cy_CapSense_Init(&amp;cy_capsense_context);</div><div class="line">    Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;CapSense_Interrupt);</div><div class="line">    NVIC_ClearPendingIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">    Cy_CapSense_Enable(&amp;cy_capsense_context);</div><div class="line">    Cy_CapSense_Save(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the CSDADC MW. */</span></div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#ga539700892c4ce6ca9c0d076a53a796a9">Cy_CSDADC_Init</a>(&amp;CSDADC_csdadc_config, &amp;cy_csdadc_context);</div><div class="line">    Cy_SysInt_Init(&amp;CSDADC_ISR_cfg, &amp;CSDADC_Interrupt);</div><div class="line">    NVIC_ClearPendingIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#gace0ef0fd816a147c2821877644da81b7">Cy_CSDADC_Enable</a>(&amp;cy_csdadc_context);</div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#gac34d548ef9dd0d65c874abff00995cab">Cy_CSDADC_Save</a>(&amp;cy_csdadc_context);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (;;)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Switches to the CapSense MW. */</span></div><div class="line">        Cy_CapSense_Restore(&amp;cy_capsense_context);</div><div class="line">        Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;CapSense_Interrupt);</div><div class="line">        <span class="comment">/* Does the CapSense sensing operation. */</span></div><div class="line">        Cy_CapSense_Save(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">        <span class="comment">/* Switches to the CSDADC MW. */</span></div><div class="line">        <a class="code" href="group__group__csdadc__functions.html#ga63d187dca4825b702bcdb5ff73a7aef7">Cy_CSDADC_Restore</a>(&amp;cy_csdadc_context);</div><div class="line">        Cy_SysInt_Init(&amp;CSDADC_ISR_cfg, &amp;CSDADC_Interrupt);</div><div class="line">        <span class="comment">/* Does the CSDADC measurement operation. */</span></div><div class="line">        <a class="code" href="group__group__csdadc__functions.html#gac34d548ef9dd0d65c874abff00995cab">Cy_CSDADC_Save</a>(&amp;cy_csdadc_context);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* ... */</span></div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>Cypress CSDADC Middleware Library 2.0</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
