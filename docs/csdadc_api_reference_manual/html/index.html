<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cypress CSDADC Middleware Library 2.0: Cypress CSDADC Middleware Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="cypress_logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cypress CSDADC Middleware Library 2.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Cypress CSDADC Middleware Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The CSDADC middleware is the Cypress ADC solution that uses the CSD HW block.The CSD HW block is mainly used to implement the touch sense applications and proximity sensors (refer to the <a href="https://cypresssemiconductorco.github.io/capsense/capsense_api_reference_manual/html/index.html"><b>CapSense Middleware API Reference Guide</b></a>), but can also be used to implement the ADC, which is especially useful for the devices that do not include another hardware option to implement the ADC. CSDADC provides the following measurement capabilities:</p><ul>
<li>Voltage monitoring on multiple external channels. Any GPIO that can be connected to AMUX-B (refer to the particular device datasheet for information) can be an input to the CSDADC under software control.</li>
<li>Voltage monitoring on AMUX-B.</li>
<li>Device supply voltage (VDDA) monitoring without the need of explicitly connecting VDDA to a GPIO input of the ADC. This capability can be used to measure battery voltages and/or change VDDA-dependent parameters of the ADC during run-time.</li>
</ul>
<p>The listed capabilities are making the CSDADC useful for a variety of applications, including home appliances, automotive, IoT, and industrial applications. The CSDADC middleware can use the same CSD HW block with other CSD-based middleware (CapSense, CSDIDAC, etc) in time-multiplexed manner.</p>
<p><b>Features:</b></p><ul>
<li>ADC with 8- and 10-bit resolution</li>
<li>Two input measurement ranges: GND to VREF and GND to VDDA</li>
<li>Two operation modes: Continuous conversion and Single-shot conversion</li>
</ul>
<h1><a class="anchor" id="section_csdadc_general"></a>
General Description</h1>
<p>Include cy_csdadc.h to get access to all functions and other declarations in this library. The <a class="el" href="index.html#group_csdadc_quick_start">Quick Start Guide</a> is offered in this API Reference Guide.</p>
<p>Refer to the <a class="el" href="index.html#section_csdadc_toolchain">Supported Software and Tools</a> for the compatibility information.</p>
<p>Refer to the <a class="el" href="index.html#group_csdadc_changelog">Changelog</a> for the differences between the Middleware versions.</p>
<p>The <a class="el" href="index.html#group_csdadc_changelog">Changelog</a> also describes the impact of the changes to your code.</p>
<p>The CSD HW block enables multiple sensing capabilities on PSoC devices including the self-cap and mutual-cap capacitive touch sensing solutions, a 10-bit ADC, IDAC, and Comparator. The CSD driver is a low-level peripheral driver, a wrapper to manage access to the CSD HW block. Any middleware access to the CSD HW block happens through the CSD Driver.</p>
<p>The CSD HW block can support only one function at a time. However, all supported functionality (like CapSense, CSDADC, etc.) can be time-multiplexed in a design. I.e. you can save the existing state of the CapSense middleware, restore the state of the CSDADC middleware, perform ADC measurements, and then switch back to the CapSense functionality. For more details and code examples, refer to the description of the <a class="el" href="group__group__csdadc__functions.html#gac34d548ef9dd0d65c874abff00995cab" title="Saves the state of the CSDADC MW so the functionality can be restored using the Cy_CSDACD_Restore() f...">Cy_CSDADC_Save()</a> and <a class="el" href="group__group__csdadc__functions.html#ga63d187dca4825b702bcdb5ff73a7aef7" title="Resumes the middleware operation if the Cy_CSDADC_Save() function was called previously. ">Cy_CSDADC_Restore()</a> functions.</p>
<div class="image">
<img src="capsense_solution.png" alt="capsense_solution.png" width="800px"/>
<div class="caption">
CapSense Solution</div></div>
 <p>This section describes only the CSDADC middleware. Refer to the corresponding sections for documentation of other middleware supported by the CSD HW block. The CSDADC library is designed to use with the CSD driver. The application program does not need to interact with the CSD driver and/or other drivers such as GPIO or SysClk directly. All of that is configured and managed by the middleware.</p>
<p>The CSDADC API is described in the following sections:</p><ul>
<li><a class="el" href="group__group__csdadc__macros.html">Macros</a></li>
<li><a class="el" href="group__group__csdadc__data__structures.html">Data Structures</a></li>
<li><a class="el" href="group__group__csdadc__enums.html">Enumerated types</a></li>
<li><a class="el" href="group__group__csdadc__functions.html">Functions</a></li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>I2C transactions during ADC conversions may lead to measurement result distortions. Perform ADC conversions and I2C communications in Time-sharing mode.</dd></dl>
<h1><a class="anchor" id="group_csdadc_quick_start"></a>
Quick Start Guide</h1>
<p>Cypress CSDADC middleware can be used in various Development Environments such as ModusToolbox, MBED, etc. Refer to the <a class="el" href="index.html#section_csdadc_toolchain">Supported Software and Tools</a>. The quickest way to get started is using the Code Examples. Cypress Semiconductor continuously extends its portfolio of the code examples at the <a href="http://www.cypress.com"><b>Cypress Semiconductor website</b></a> and at the <a href="https://github.com/cypresssemiconductorco"><b>Cypress Semiconductor GitHub</b></a>.</p>
<p>This quick start guide assumes that the environment is configured to use the PSoC 6 Peripheral Driver Library(psoc6pdl) for development and the PSoC 6 Peripheral Driver Library(psoc6pdl) is included in the project.</p>
<p>The following steps are required to set up the CSDADC and to run the measurement:</p><ol type="1">
<li>Set up the CSDADC configuration manually or by using the Device Configurator as described in the <a class="el" href="index.html#group_csdadc_configuration">Configuration Considerations</a> section. <dl class="section note"><dt>Note</dt><dd>Put the CSDADC name to the Alias field of the CSD resource if the Device Configurator is used.</dd></dl>
</li>
<li>Include cy_csdadc.h to get access to all CSDADC API and cy_pdl.h to get access to API of peripheral drivers according to the example below: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cy_pdl.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;cy_csdadc.h&quot;</span></div></div><!-- fragment --></li>
<li>If you use the MBED OS, include the cycfg.h file to get access to the System Configuration: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;cycfg.h&quot;</span></div></div><!-- fragment --></li>
<li>Declare the 'cy_csdadc_context' variable as per example below: <div class="fragment"><div class="line"><span class="comment">/* CSDADC context declaration */</span></div><div class="line"><a class="code" href="structcy__stc__csdadc__context__t.html">cy_stc_csdadc_context_t</a> cy_csdadc_context;</div></div><!-- fragment --></li>
<li>Declare and initialize the CSDADC_ISR_cfg variable as per example below: <div class="fragment"><div class="line"></div><div class="line"><span class="keyword">const</span> cy_stc_sysint_t CSDADC_ISR_cfg =</div><div class="line">{</div><div class="line">    .intrSrc = csd_interrupt_IRQn,  <span class="comment">/* Interrupt source is the CSD interrupt */</span></div><div class="line">    .intrPriority = 7u,             <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line">};</div><div class="line"></div></div><!-- fragment --></li>
<li>Define the CSDADC interrupt handler according to the example below: <div class="fragment"><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> CSDADC_Interrupt(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#ga514703b9e2da7cc3adf497198558e9b0">Cy_CSDADC_InterruptHandler</a>(CSDADC_HW, &amp;cy_csdadc_context);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --></li>
<li>Update the main() routine with the following code: <div class="fragment"><div class="line">    uint32_t ch0Result;</div><div class="line">    uint32_t ch1Result;</div></div><!-- fragment --><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* The mask to enable conversion on Channel-0 and Channel-1. */</span></div><div class="line">    uint32_t channelsMask = 0x03u;</div><div class="line"></div><div class="line">    <span class="comment">/* UNCOMMENT THIS CODE if you use the MBED OS: */</span></div><div class="line">    <span class="comment">//init_cycfg_clocks();</span></div><div class="line">    <span class="comment">//init_cycfg_routing();</span></div><div class="line">    <span class="comment">//init_cycfg_peripherals();</span></div><div class="line"></div><div class="line">    <span class="comment">/* UNCOMMENT THIS CODE if you Implement the initialization code manually</span></div><div class="line"><span class="comment">    *  to Assign the Peripheral Clock Divider to the CSD HW block.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="comment">//Cy_SysClk_PeriphAssignDivider(PCLK_CSD_CLOCK, CY_SYSCLK_DIV_8_BIT, 0u);</span></div><div class="line"></div><div class="line">    <span class="comment">/* UNCOMMENT THIS CODE if you Implement the initialization code manually to</span></div><div class="line"><span class="comment">    *  set configuration of the HSIOM_AMUX_SPLIT_CTL switches.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="comment">//#if(1u == CY_IP_MXS40IOSS_VERSION)</span></div><div class="line">    <span class="comment">//  HSIOM-&gt;AMUX_SPLIT_CTL[4] = HSIOM_AMUX_SPLIT_CTL_SWITCH_BB_SL_Msk |</span></div><div class="line">    <span class="comment">//                             HSIOM_AMUX_SPLIT_CTL_SWITCH_BB_SR_Msk;</span></div><div class="line">    <span class="comment">//#elif(2u == CY_IP_MXS40IOSS_VERSION)</span></div><div class="line">    <span class="comment">//  HSIOM-&gt;AMUX_SPLIT_CTL[4] = HSIOM_V2_AMUX_SPLIT_CTL_SWITCH_BB_SL_Msk |</span></div><div class="line">    <span class="comment">//                             HSIOM_V2_AMUX_SPLIT_CTL_SWITCH_BB_SR_Msk;</span></div><div class="line">    <span class="comment">//#else</span></div><div class="line">    <span class="comment">//  #error Not supported device</span></div><div class="line">    <span class="comment">//#endif</span></div><div class="line"></div><div class="line">    <span class="comment">/* Captures the CSD HW block and Initializes it to the default state. */</span></div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#ga539700892c4ce6ca9c0d076a53a796a9">Cy_CSDADC_Init</a>(&amp;CSDADC_csdadc_config, &amp;cy_csdadc_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the CSDADC interrupt. */</span></div><div class="line">    Cy_SysInt_Init(&amp;CSDADC_ISR_cfg, &amp;CSDADC_Interrupt);</div><div class="line">    NVIC_ClearPendingIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the CSDADC  firmware modules. */</span></div><div class="line">    <a class="code" href="group__group__csdadc__functions.html#gace0ef0fd816a147c2821877644da81b7">Cy_CSDADC_Enable</a>(&amp;cy_csdadc_context);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(;;)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__csdadc__enums.html#gga2fb51073513c86f28616c29901c55a40a18e1e8f2c080c1697eaf0de8757a2ae4">CY_CSDADC_SUCCESS</a> == <a class="code" href="group__group__csdadc__functions.html#ga2fe1d5b92fcbbb85230cce544818ce59">Cy_CSDADC_StartConvert</a>(<a class="code" href="group__group__csdadc__enums.html#ggaa708440f81ca9ab9606919c8a2b55f7ba68c510fb301d723422dd6ea2fbed7f93">CY_CSDADC_SINGLE_SHOT</a>, channelsMask, &amp;cy_csdadc_context))</div><div class="line">        {</div><div class="line">            <span class="keywordflow">while</span> (<a class="code" href="group__group__csdadc__enums.html#gga2fb51073513c86f28616c29901c55a40a18e1e8f2c080c1697eaf0de8757a2ae4">CY_CSDADC_SUCCESS</a> != <a class="code" href="group__group__csdadc__functions.html#gabb93b3cee2724658cd14d603569cbba6">Cy_CSDADC_IsEndConversion</a>(&amp;cy_csdadc_context))</div><div class="line">            {</div><div class="line">                <span class="comment">/* Waits for the end of conversions. */</span></div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">/* Stores the Channel-0 measurement result to the ch0Result variable. */</span></div><div class="line">            ch0Result = <a class="code" href="group__group__csdadc__functions.html#gac7f07b8602ab61912a1f3424d5a864c0">Cy_CSDADC_GetResultVoltage</a>(0u, &amp;cy_csdadc_context);</div><div class="line">            <span class="comment">/* Stores the Channel-1 measurement result to the ch1Result variable. */</span></div><div class="line">            ch1Result = <a class="code" href="group__group__csdadc__functions.html#gac7f07b8602ab61912a1f3424d5a864c0">Cy_CSDADC_GetResultVoltage</a>(1u, &amp;cy_csdadc_context);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></li>
</ol>
<h1><a class="anchor" id="group_csdadc_configuration"></a>
Configuration Considerations</h1>
<p>The CSDADC middleware operates on the top of the CSD Driver included in the PSoC 6 Peripheral Driver Library (psoc6pdl). Refer to the "CSD(CapSense
Sigma Delta)" section of the PSoC 6 Peripheral Driver Library (psoc6pdl) API Reference Manual. This Configuration Considerations section guides how to set up the CSDADC middleware for the operation with the following parameters:</p><ol type="1">
<li>Device VDDA: 3.3V.</li>
<li>Device Peri Clock frequency: 48MHz.</li>
<li>Desired Number of Input Channels: 2 (Ch-1 is assigned to P6[2], Ch-2 is assigned to P6[3]).</li>
<li>Desired Resolution: 10 bit.</li>
<li>Desired Measurement Range: GND to VDDA.</li>
</ol>
<p>There are two methods for the CSDADC Middleware configuration:</p><ol type="1">
<li><a class="el" href="index.html#group_csdadc_mtb_configuring">Use ModusToolbox Device Configurator Tool to generate initialization code</a></li>
<li><a class="el" href="index.html#group_csdadc_manual_configuring">Implement the initialization code manually</a></li>
</ol>
<p>Generation of the initialization code using the <a href="https://www.cypress.com/ModusToolboxDeviceConfig"><b>ModusToolbox Device Configurator Tool </b></a> which is part of the <a href="https://www.cypress.com/products/modustoolbox-software-environment"><b>ModusToolbox</b></a>, greatly simplifies the PSoC configuration. The <a href="https://www.cypress.com/ModusToolboxDeviceConfig"><b>ModusToolbox Device Configurator Tool </b></a> provides the user interface to set up and automatically generate the initialization code (including analog routing) and configuration structures.</p>
<p>Manual implementation of the initialization code (including analog routing) and configuration structures is recommended for expert Users only. This will include the code for the following settings which in case of the Device Configurator usage are generated automatically based upon the settings entered in its UI:</p><ul>
<li>Assigning the Peripheral Clock Divider.</li>
<li>Configuring the HSIOM_AMUX_SPLIT_CTL switches to route signal from input pins configured as the CSDADC channels to the CSD HW block.</li>
<li>Declaration and initialization of the CSDADC configuration structure.</li>
<li>Declaration and initialization of the CSD HW driver context structure.</li>
<li>Definition of the of the CSD HW block base address.</li>
</ul>
<h2><a class="anchor" id="group_csdadc_mtb_configuring"></a>
Use ModusToolbox Device Configurator Tool to generate initialization code</h2>
<p>The following steps are required to generate the initialization code using the <a href="https://www.cypress.com/ModusToolboxDeviceConfig"><b>ModusToolbox Device Configurator Tool </b></a>:</p><ol type="1">
<li>Launch the ModusToolbox Middleware Selector and enable the CSD ADC middleware. This step is required only if the ModusToolbox IDE is used. Otherwise, ensure the CSDADC Middleware is included in your project.</li>
<li>Launch the ModusToolbox Device Configurator Tool.</li>
<li>Switch to the System tab. Configure the CLK_PERI frequency to achieve 48MHz (you may need to change the FLL or PLL frequency) and set the VDDA voltage to 3.3V in Power/MCU Personality.</li>
<li>Switch to the Peripherals tab (#1 on figure below). Enable the CSD personality under System (#2 on figure below) and enter Alias (#3 on figure below). We use CSDADC in <a class="el" href="index.html#group_csdadc_quick_start">Quick Start Guide</a>.</li>
<li>Go to the Parameters Pane and configure the CSD Personality:<ul>
<li>Assign the peripheral clock divider by using the Clock combo box(#4 on figure below). Any free divider can be used.</li>
<li>Set the Enable CSDADC check box (#5 on figure below).</li>
<li>Configure the CSDADC with the desired parameters per <a class="el" href="index.html#group_csdadc_configuration">Configuration Considerations</a> (#5 on figure below).</li>
<li>Assign the CSDADC Channels to pins per <a class="el" href="index.html#group_csdadc_configuration">Configuration Considerations</a> (#6 on figure below).</li>
</ul>
</li>
<li>Perform File-&gt;Save to generate initialization code.</li>
</ol>
<div class="image">
<img src="csdadc_config.png" alt="csdadc_config.png" width="1175px"/>
<div class="caption">
CSDADC configuration</div></div>
 <p>Now, all required CSDADC initialization code and configuration prerequisites will be generated:</p><ul>
<li>The Peripheral Clock Divider assignment and analog routing are parts of the init_cycfg_all() routine. Place the call of the init_cycfg_all() function before using any CSDADC API functions to ensure initialization of all external resources required for the CSDADC operation. Refer to the main() routine code snippet in <a class="el" href="index.html#group_csdadc_quick_start">Quick Start Guide</a></li>
<li>The CSDADC configuration structure declaration in the cycfg_peripherals.h file and its initialization in the cycfg_peripherals.c file. The variable name is &lt;Alias_Name&gt;_csdadc_config.</li>
<li>The CSD HW driver context structure declaration in the cycfg_peripherals.h file and its initialization in the cycfg_peripherals.c file. The variable name is cy_csd_&lt;CSD_Block_Index&gt;_context.</li>
<li>The CSD HW block base address definition is in the cycfg_peripherals.h file.</li>
<li>The definition name is &lt;Alias_Name&gt;_HW.</li>
</ul>
<p>The generated code will be available under the GeneratedSource folder.</p>
<p>Refer to <a class="el" href="index.html#group_csdadc_quick_start">Quick Start Guide</a> section for the application layer code required to set up CSDADC and run the measurement.</p>
<h2><a class="anchor" id="group_csdadc_manual_configuring"></a>
Implement the initialization code manually</h2>
<p>The steps required to implement the initialization code manually:</p><ol type="1">
<li>Launch the ModusToolbox Middleware Selector and enable the CSD ADC middleware. This step is required only if the ModusToolbox IDE is used. Otherwise, ensure the CSDADC Middleware is included in your project.</li>
<li>Define the CSD HW block base address. See the code example below: <div class="fragment"><div class="line"><span class="preprocessor">#define CSDADC_HW                               (CSD0)</span></div></div><!-- fragment --></li>
<li>Declare the CSD HW driver context structure and initialize the lockKey field with the CY_CSD_NONE_KEY value. See the code example below: <div class="fragment"><div class="line">cy_stc_csd_context_t cy_csd_context =</div><div class="line">{</div><div class="line">    .lockKey = CY_CSD_NONE_KEY,     <span class="comment">/* Initialization of the lockKey with the CY_CSD_NONE_KEY</span></div><div class="line"><span class="comment">                                       is required */</span></div><div class="line">};</div></div><!-- fragment --></li>
<li>Declare the CSDADC configuration structure and initialize it according to the desired parameters. See the code example below: <div class="fragment"><div class="line"><span class="preprocessor">#define PERI_DIV_INDEX_0                        (0u)</span></div></div><!-- fragment --><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structcy__stc__csdadc__ch__pin__t.html">cy_stc_csdadc_ch_pin_t</a> chList[2u] =</div><div class="line">{</div><div class="line">    {GPIO_PRT6, 2u},                <span class="comment">/* Assign channel-0 to P6[2] */</span></div><div class="line">    {GPIO_PRT6, 3u}                 <span class="comment">/* Assign channel-1 to P6[3] */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structcy__stc__csdadc__config__t.html">cy_stc_csdadc_config_t</a> CSDADC_csdadc_config =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__csdadc__config__t.html#af0839917f36aa586434fd2c07a042043">ptrPinList</a> = chList,                       <span class="comment">/* Points to the array with configured CSDACD Ports/Pins. */</span></div><div class="line">    .base = CSDADC_HW,                          <span class="comment">/* The CSD0 HW block is selected for CSDADC operation. */</span></div><div class="line">    .csdCxtPtr = &amp;cy_csd_context,               <span class="comment">/* Points to the CSD driver context structure. */</span></div><div class="line">    .cpuClk = 48000000u,                        <span class="comment">/* Provides an absolute CPU clock frequency in the current design (configured to 48MHz). */</span></div><div class="line">    .periClk = 48000000u,                       <span class="comment">/* Provides an absolute Peri clock frequency in the current design (configured to 48MHz). */</span></div><div class="line">    .vref = -1,                                 <span class="comment">/* Sets auto-selection of the reference voltage. */</span></div><div class="line">    .vdda = 3300u,                              <span class="comment">/* Provides Supply Voltage in the current design (configured to 3.3V). */</span></div><div class="line">    .calibrInterval = 0u,                       <span class="comment">/* Reserved for further enhancements. */</span></div><div class="line">    .range = <a class="code" href="group__group__csdadc__enums.html#gga9a51f670bcf385f7f2cbaa3f1491cc7fab08c3bcb3f06d7cd7c0e1bed9b17df8c">CY_CSDADC_RANGE_VDDA</a>,              <span class="comment">/* Selects the measurement range (configured to GND to VDDA). */</span></div><div class="line">    .resolution = <a class="code" href="group__group__csdadc__enums.html#gga53be63f99ad2c3e775496df7c8957bc7a9332e87810c8e564b2fa586aede1193d">CY_CSDADC_RESOLUTION_10BIT</a>,   <span class="comment">/* Selects the measurement resolution (configured to the 10-bit resolution). */</span></div><div class="line">    .periDivTyp = CY_SYSCLK_DIV_8_BIT,          <span class="comment">/* Pass the type of clock divider, used to clock the CSD HW block.</span></div><div class="line"><span class="comment">                                                   On the application layer, assign the same type divider by using the</span></div><div class="line"><span class="comment">                                                   Cy_SysClk_PeriphAssignDivider() function. The CSDADC middleware requires information</span></div><div class="line"><span class="comment">                                                   about the used divider to be able to control it in the run time (enable/disable, change value). */</span></div><div class="line">    .numChannels = 2u,                          <span class="comment">/* Configured CSDADC MW to measure the voltage on two channels. */</span></div><div class="line">    .idac = 31u,                                <span class="comment">/* Reserved for further enhancements. */</span></div><div class="line">    .operClkDivider = 1u,                       <span class="comment">/* Defines the value to be set by CSDADC in the run time to the clock divider, assigned on</span></div><div class="line"><span class="comment">                                                   the application layer by using the Cy_SysClk_PeriphAssignDivider() function. The Max supported</span></div><div class="line"><span class="comment">                                                   clock frequency for the CSD HW block is 50 MHz. The divider value &quot;1&quot; is used, </span></div><div class="line"><span class="comment">                                                   because in the current case the Peri Clock frequency is 48 MHz. */</span></div><div class="line">    .azTime = 5u,                               <span class="comment">/* Configures Auto-zero time to 5 us (as default). */</span></div><div class="line">    .acqTime = 10u,                             <span class="comment">/* Configures Acquisition time to 10 us (as default). */</span></div><div class="line">    .csdInitTime = 25u,                         <span class="comment">/* Configures the CSD0 wake-up initialization time to 25 us (as default). */</span></div><div class="line">    .idacCalibrationEn = 0u,                    <span class="comment">/* Reserved for further enhancements. */</span></div><div class="line">    .periDivInd = PERI_DIV_INDEX_0,             <span class="comment">/* Pass the index of the clock divider used to clock the CSD HW block. </span></div><div class="line"><span class="comment">                                                   Assign divider with the same index on the application layer by using the</span></div><div class="line"><span class="comment">                                                   Cy_SysClk_PeriphAssignDivider() function. The CSDADC middleware requires information</span></div><div class="line"><span class="comment">                                                   about the used divider to be able to control it in the run time (enable/disable, change value). */</span></div><div class="line">};</div></div><!-- fragment --></li>
<li>Assign the Peripheral Clock Divider to the CSD HW block. See the code example below and refer to the main() routine code snippet in <a class="el" href="index.html#group_csdadc_quick_start">Quick Start Guide</a> <div class="fragment"><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">* The user responsibility is to assign the peripheral clock divider to the</span></div><div class="line"><span class="comment">* CSD HW block on application layer. Any free divider of any type can be used.</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* PCLK_CSD_CLOCK - connect divider to the CSD HW block</span></div><div class="line"><span class="comment">* CY_SYSCLK_DIV_8_BIT - use 8-bit divider.</span></div><div class="line"><span class="comment">* PERI_DIV_INDEX_0 - select divider with index #0. </span></div><div class="line"><span class="comment">*/</span></div><div class="line">Cy_SysClk_PeriphAssignDivider(PCLK_CSD_CLOCK, CY_SYSCLK_DIV_8_BIT, PERI_DIV_INDEX_0);</div><div class="line"></div></div><!-- fragment --></li>
<li>Set the configuration of the HSIOM_AMUX_SPLIT_CTL switches to route signal from input pins configured as the CSDADC channels to the CSD HW block. The AMUX_SPLIT_CTL[4] switches are closed to connect port P6 with the CSD HW block. Refer to the <a href="http://www.cypress.com/trm218176"><b>Technical Reference Manual (TRM)</b></a> for more information regarding the analog interconnection. See the code example below and refer to the main() routine code snippet in <a class="el" href="index.html#group_csdadc_quick_start">Quick Start Guide</a> <div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#if(1u == CY_IP_MXS40IOSS_VERSION)</span></div><div class="line">    HSIOM-&gt;AMUX_SPLIT_CTL[4] = HSIOM_AMUX_SPLIT_CTL_SWITCH_BB_SL_Msk |      <span class="comment">/* Closes the left AMUX-B switch of AMUX splitter #4. */</span></div><div class="line">                               HSIOM_AMUX_SPLIT_CTL_SWITCH_BB_SR_Msk;       <span class="comment">/* Closes the right AMUX-B switch of AMUX splitter #4. */</span></div><div class="line"><span class="preprocessor">#elif(2u == CY_IP_MXS40IOSS_VERSION)</span></div><div class="line">    HSIOM-&gt;AMUX_SPLIT_CTL[4] = HSIOM_V2_AMUX_SPLIT_CTL_SWITCH_BB_SL_Msk |   <span class="comment">/* Closes the left AMUX-B switch of AMUX splitter #4. */</span></div><div class="line">                               HSIOM_V2_AMUX_SPLIT_CTL_SWITCH_BB_SR_Msk;    <span class="comment">/* Closes the right AMUX-B switch of AMUX splitter #4. */</span></div><div class="line"><span class="preprocessor">#else</span></div><div class="line"><span class="preprocessor">    #error Not supported device</span></div><div class="line"><span class="preprocessor">#endif </span><span class="comment">/* (1u == CY_IP_MXS40IOSS_VERSION) */</span><span class="preprocessor"></span></div><div class="line"></div></div><!-- fragment --> Refer to <a class="el" href="index.html#group_csdadc_quick_start">Quick Start Guide</a> section for the application layer code required to set up CSDADC and run the measurement.</li>
</ol>
<h1><a class="anchor" id="group_csdadc_use_cases"></a>
Use Cases</h1>
<p>This section provides descriptions and links to additional documentation for some specific CSDADC use cases.</p>
<h2><a class="anchor" id="group_csdadc_low_power_design"></a>
Low Power Design</h2>
<p>The CSD HW block and CSDADC middleware can operate in CPU active and CPU sleep power modes. It is also possible to switch between low power and ultra low power system modes. The CSD HW block interrupt can wake-up the CPU from sleep mode. In System Deep Sleep and Hibernate power modes, the CSD HW block is powered off and CSDADC conversions are not performed. When the device wakes up from CPU / System Deep Sleep, the CSD HW block resumes operation without the need for re-initialization and the CSDADC conversions can be continued with a configuration that was set before CPU / System Deep Sleep transition. When the device wakes up from System Hibernate power mode, the CSD HW block does not retain configuration and CSDADC requires re-initialization. If the user performs some communications to transmit CSDADC results via I2C, UART etc., transitions to CPU sleep, Deep Sleep or Hibernate modes are performed with recommendations both for CSDADC and communications' drivers/middleware.</p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>CPU can seamlessly enter and exit CPU sleep mode while the CSD HW block is busy. However, do not put the CSD HW block into block low power mode during the conversion as it may lead to unexpected behavior.</li>
<li>Entering CPU Deep Sleep mode does not mean the device enters System Deep Sleep. For more detail about switching to System Deep Sleep, refer to the device TRM.</li>
<li>The analog start-up time for the CSD HW block is 25 us. Initiate any kind of conversion only after 25 us from System Deep Sleep / Hibernate exit.</li>
</ol>
</dd></dl>
<p>Refer to the <a class="el" href="group__group__csdadc__functions.html#gae5a2d7cf6f3e1c4ce0da1512480dc9c8" title="Handles CPU active to CPU / System Deep Sleep power mode transitions for the CSDADC middleware...">Cy_CSDADC_DeepSleepCallback()</a> function description and to the SysPm (System Power Management) driver documentation for the low power design considerations.</p>
<p><b>Sleep mode</b><br />
 The CSD HW block can operate in the CPU sleep mode. The user can start CSDADC and move a CPU into sleep mode. After every conversion, the CPU is woken-up by the CSD interrupt, the results are read, and the CPU goes to sleep again to reduce a power consumption. After the whole conversion cycle completes, the user can read results, proccess them, and start a new cycle. Then, the user configures the CSDADC middleware as described in <a class="el" href="index.html#group_csdadc_configuration">Configuration Considerations</a>, and updates the main() routine with the following code: </p><div class="fragment"><div class="line">  <span class="comment">/* Scenario: There is a need to measure two input voltages while CPU is in Sleep mode </span></div><div class="line"><span class="comment">   * during conversions. */</span></div><div class="line"></div><div class="line">   <span class="comment">/* ... */</span></div><div class="line">    <span class="keywordflow">for</span> (;;)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Starts CSDADC measuring of the two input channel voltages. */</span></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__csdadc__enums.html#gga2fb51073513c86f28616c29901c55a40a18e1e8f2c080c1697eaf0de8757a2ae4">CY_CSDADC_SUCCESS</a> == <a class="code" href="group__group__csdadc__functions.html#ga2fe1d5b92fcbbb85230cce544818ce59">Cy_CSDADC_StartConvert</a>(<a class="code" href="group__group__csdadc__enums.html#ggaa708440f81ca9ab9606919c8a2b55f7ba68c510fb301d723422dd6ea2fbed7f93">CY_CSDADC_SINGLE_SHOT</a>, channelsMask, &amp;cy_csdadc_context))</div><div class="line">        {</div><div class="line">            <span class="keywordflow">while</span> (<a class="code" href="group__group__csdadc__enums.html#gga2fb51073513c86f28616c29901c55a40a18e1e8f2c080c1697eaf0de8757a2ae4">CY_CSDADC_SUCCESS</a> != <a class="code" href="group__group__csdadc__functions.html#gabb93b3cee2724658cd14d603569cbba6">Cy_CSDADC_IsEndConversion</a>(&amp;cy_csdadc_context))</div><div class="line">            {</div><div class="line">                 <span class="comment">/* </span></div><div class="line"><span class="comment">                  * Goes to CPU Sleep mode and waits for a CSDADC interrupt. </span></div><div class="line"><span class="comment">                  * CSDADC handles the interrupt and CPU enters Sleep mode again.</span></div><div class="line"><span class="comment">                  * The results are being read and proccessed after the whole </span></div><div class="line"><span class="comment">                  * conversion cycle completion.</span></div><div class="line"><span class="comment">                  */</span></div><div class="line">                <span class="keywordflow">if</span>(CY_SYSPM_SUCCESS != Cy_SysPm_CpuEnterSleep(CY_SYSPM_WAIT_FOR_INTERRUPT))</div><div class="line">                {</div><div class="line">                    <span class="comment">/* You can place error handler code here. */</span></div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="comment">/* Stores the Channel-0 measurement result to the ch0Result variable. */</span></div><div class="line">            ch0Result = <a class="code" href="group__group__csdadc__functions.html#gac7f07b8602ab61912a1f3424d5a864c0">Cy_CSDADC_GetResultVoltage</a>(0u, &amp;cy_csdadc_context);</div><div class="line">            <span class="comment">/* Stores the Channel-1 measurement result to the ch1Result variable. */</span></div><div class="line">            ch1Result = <a class="code" href="group__group__csdadc__functions.html#gac7f07b8602ab61912a1f3424d5a864c0">Cy_CSDADC_GetResultVoltage</a>(1u, &amp;cy_csdadc_context);</div><div class="line">            <span class="comment">/* </span></div><div class="line"><span class="comment">             * Insert here a CSDADC data processing here, because the data will be lost </span></div><div class="line"><span class="comment">             * after the next Sleep entering.</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            </div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* You can place error handler code here. */</span></div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p> <b>Deep Sleep mode</b><br />
 To use the CSDADC middleware in the CPU / System Deep Sleep mode, the user configures a wake-up source (e.g. a pin, WDT, LPC or another entities, that are active in CPU / System Deep Sleep mode), configures the CSDADC middleware as described in <a class="el" href="index.html#group_csdadc_configuration">Configuration Considerations</a>, configures CSDADC and other drivers' and middleware's (if presented) Deep Sleep Callback structures, registers callbacks, and updates the main() routine with the following code: </p><div class="fragment"><div class="line"><span class="comment">/* CSDADC DeepSleep Callback parameters structure */</span></div><div class="line">cy_stc_syspm_callback_params_t CSDADC_deepSleepParamStr =</div><div class="line">{</div><div class="line">    CSDADC_HW,                      <span class="comment">/* Points to the CSD HW block base */</span></div><div class="line">    &amp;cy_csdadc_context,             <span class="comment">/* Points to the CSDADC context structure */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/*  CSDADC DeepSleep Callback structure */</span></div><div class="line">cy_stc_syspm_callback_t CSDADC_deepSleepCallbackStr =</div><div class="line">{</div><div class="line">    &amp;<a class="code" href="group__group__csdadc__functions.html#gae5a2d7cf6f3e1c4ce0da1512480dc9c8">Cy_CSDADC_DeepSleepCallback</a>,   <span class="comment">/* Points to the CSDADC Callback function */</span></div><div class="line">    CY_SYSPM_DEEPSLEEP,             <span class="comment">/* The Callback type */</span></div><div class="line">    0u,                             <span class="comment">/* The skip modes mask */</span></div><div class="line">    &amp;CSDADC_deepSleepParamStr,      <span class="comment">/* Points to the Callback parameters structure */</span></div><div class="line">    NULL,                           <span class="comment">/* Reserved */</span></div><div class="line">    NULL,                           <span class="comment">/* Reserved */</span></div><div class="line">    10u,                            <span class="comment">/* The callback priority, can be from 1 (the highest) to 255 (the lowest)*/</span></div><div class="line">};</div></div><!-- fragment --><div class="fragment"><div class="line">  <span class="comment">/* Scenario: There is a need to measure two input voltages one time </span></div><div class="line"><span class="comment">   * per one wake-up event, and the rest of time the CPU should be in Deep Sleep mode. */</span></div><div class="line"></div><div class="line">   <span class="comment">/* ... */</span></div><div class="line">   <span class="comment">/* Registers CSDADC DeepSleep Callback. */</span></div><div class="line">    <span class="keywordflow">if</span> (<span class="keyword">true</span> != Cy_SysPm_RegisterCallback(&amp;CSDADC_deepSleepCallbackStr))</div><div class="line">    {</div><div class="line">       <span class="comment">/* You can place error handler code here. */</span></div><div class="line">    }</div><div class="line">   <span class="comment">/* ... */</span>  </div><div class="line">    <span class="keywordflow">for</span> (;;)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Waits for the conversions completion */</span></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__csdadc__enums.html#gga2fb51073513c86f28616c29901c55a40a18e1e8f2c080c1697eaf0de8757a2ae4">CY_CSDADC_SUCCESS</a> == <a class="code" href="group__group__csdadc__functions.html#gabb93b3cee2724658cd14d603569cbba6">Cy_CSDADC_IsEndConversion</a>(&amp;cy_csdadc_context))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Stores the Channel-0 measurement result to the ch0Result variable. */</span></div><div class="line">            ch0Result = <a class="code" href="group__group__csdadc__functions.html#gac7f07b8602ab61912a1f3424d5a864c0">Cy_CSDADC_GetResultVoltage</a>(0u, &amp;cy_csdadc_context);</div><div class="line">            <span class="comment">/* Stores the Channel-1 measurement result to the ch1Result variable. */</span></div><div class="line">            ch1Result = <a class="code" href="group__group__csdadc__functions.html#gac7f07b8602ab61912a1f3424d5a864c0">Cy_CSDADC_GetResultVoltage</a>(1u, &amp;cy_csdadc_context);</div><div class="line">            <span class="comment">/* </span></div><div class="line"><span class="comment">             * Insert CSDADC data processing here, because the data will be lost </span></div><div class="line"><span class="comment">             * after the next DeepSleep entering.</span></div><div class="line"><span class="comment">             * ...             </span></div><div class="line"><span class="comment">             * After the CSDADC data proccessing completion, the CPU goes to Deep Sleep</span></div><div class="line"><span class="comment">             * and waits for an interrupt. It is the user&#39;s responsibility </span></div><div class="line"><span class="comment">             * to provide an interrupt source for a reliable CPU wake-up.</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            <span class="keywordflow">if</span>(CY_SYSPM_SUCCESS != Cy_SysPm_CpuEnterDeepSleep(CY_SYSPM_WAIT_FOR_INTERRUPT))</div><div class="line">            {</div><div class="line">                <span class="comment">/* You can place error handler code here. */</span></div><div class="line">            }</div><div class="line">            <span class="comment">/* Wakes up CSDADC after a successful exit from Deep Sleep. */</span></div><div class="line">            <a class="code" href="group__group__csdadc__functions.html#gafa9c2a4610c5f2e242c1c01c79511560">Cy_CSDADC_Wakeup</a>(&amp;cy_csdadc_context);</div><div class="line">            <span class="comment">/*</span></div><div class="line"><span class="comment">             * After Deep Sleep, CPU and CSD HW block wake-up, CSDADC starts with two input channel voltages measuring.</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            <span class="keywordflow">if</span> (<a class="code" href="group__group__csdadc__enums.html#gga2fb51073513c86f28616c29901c55a40a18e1e8f2c080c1697eaf0de8757a2ae4">CY_CSDADC_SUCCESS</a> != <a class="code" href="group__group__csdadc__functions.html#ga2fe1d5b92fcbbb85230cce544818ce59">Cy_CSDADC_StartConvert</a>(<a class="code" href="group__group__csdadc__enums.html#ggaa708440f81ca9ab9606919c8a2b55f7ba68c510fb301d723422dd6ea2fbed7f93">CY_CSDADC_SINGLE_SHOT</a>, channelsMask, &amp;cy_csdadc_context))</div><div class="line">            {</div><div class="line">                <span class="comment">/* </span></div><div class="line"><span class="comment">                 * You can place error handler code here.</span></div><div class="line"><span class="comment">                 * A software watchdog can be inserted here as well </span></div><div class="line"><span class="comment">                 * to prevent a CSDADC hangout. </span></div><div class="line"><span class="comment">                 */</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* </span></div><div class="line"><span class="comment">             * Insert here some code, that can be done during CSDADC conversions </span></div><div class="line"><span class="comment">             * (if it is needed).</span></div><div class="line"><span class="comment">             */</span>            </div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><h2><a class="anchor" id="group_csdadc_calibration"></a>
ADC calibration</h2>
<p>Refer to the <a class="el" href="group__group__csdadc__functions.html#ga2d96acbd1f2eae47d4bd97e41e0a3b7a" title="Performs calibration of the CSDADC. ">Cy_CSDADC_Calibrate()</a> function description for the CSDADC calibration considerations. <a class="el" href="group__group__csdadc__functions.html#gace0ef0fd816a147c2821877644da81b7" title="Initializes the CSDADC firmware modules. ">Cy_CSDADC_Enable()</a> performs first-time calibration at the start of CSDADC operation. Periodical re-calibrations are required to keep the measurement results accurate.</p>
<h2><a class="anchor" id="group_csdadc_time_multiplexing"></a>
Time-multiplexing operation of CSDADC and CapSense</h2>
<p>Refer to the <a class="el" href="group__group__csdadc__functions.html#gac34d548ef9dd0d65c874abff00995cab" title="Saves the state of the CSDADC MW so the functionality can be restored using the Cy_CSDACD_Restore() f...">Cy_CSDADC_Save()</a> and <a class="el" href="group__group__csdadc__functions.html#ga63d187dca4825b702bcdb5ff73a7aef7" title="Resumes the middleware operation if the Cy_CSDADC_Save() function was called previously. ">Cy_CSDADC_Restore()</a> functions descriptions to implementat the time-multiplexing operation of CSDADC and CapSense by using a common CSD HW block.</p>
<h1><a class="anchor" id="section_csdadc_toolchain"></a>
Supported Software and Tools</h1>
<p>This version of the CSDADC Middleware was validated for the compatibility with the following Software and Tools:</p>
<table class="doxtable">
<tr>
<th>Software and Tools </th><th>Version  </th></tr>
<tr>
<td>ModusToolbox Software Environment </td><td>2.0  </td></tr>
<tr>
<td>- ModusToolbox Device Configurator </td><td>2.0  </td></tr>
<tr>
<td>- ModusToolbox CSD Personality in Device Configurator </td><td>2.0  </td></tr>
<tr>
<td>PSoC6 Peripheral Driver Library (PDL) </td><td>1.2.0  </td></tr>
<tr>
<td>GCC Compiler </td><td>7.2.1  </td></tr>
<tr>
<td>IAR Compiler </td><td>8.32  </td></tr>
<tr>
<td>Arm Compiler 6 </td><td>6.11  </td></tr>
<tr>
<td>MBED OS </td><td>5.13.1  </td></tr>
<tr>
<td>FreeRTOS </td><td>10.0.1  </td></tr>
</table>
<h1><a class="anchor" id="section_csdadc_update"></a>
Update to Newer Versions</h1>
<p>Consult <a class="el" href="index.html#group_csdadc_changelog">Changelog</a> to learn about the design impact of the newer version. Set up your environment in accordance with <a class="el" href="index.html#section_csdadc_toolchain">Supported Software and Tools</a>. You might need to re-generate the configuration structures for either the device initialization code or the middleware initialization code.</p>
<p>Ensure:</p><ul>
<li>The specified version of the ModusToolbox Device Configurator and the CSD personality are used to re-generate the device configuration.</li>
<li>The toolchains are set up properly for your environment per the settings outlined in the Supported Software and Tools.</li>
<li>The project is re-built once the the toolchains are configured and the configuration is completed.</li>
</ul>
<h1><a class="anchor" id="group_csdadc_MISRA"></a>
MISRA-C Compliance</h1>
<p>The Cy_CSDADC library has the following specific deviations:</p>
<table class="doxtable">
<tr>
<th>MISRA Rule </th><th>Rule Class (Required/Advisory) </th><th>Rule Description </th><th>Description of Deviation(s)  </th></tr>
<tr>
<td>11.4 </td><td>A </td><td>A conversion should not be performed between a pointer to object and an integer type. </td><td>Such a conversion is performed with the CSDADC context in two cases: the interrupt handler and DeepSleepCallback function. Both cases are verified on the correct operation.  </td></tr>
<tr>
<td>1.2 </td><td rowspan="2">R </td><td rowspan="2">Constant: Dereference of NULL pointer. </td><td rowspan="2">These violations are reported to result from using offset macros of the CSD Driver with corresponding documented violation 20.6. Refer to the CSD Driver API Ref Guide.  </td></tr>
<tr>
<td>20.3  </td></tr>
</table>
<h1><a class="anchor" id="section_csdadc_errata"></a>
Errata</h1>
<p>This section lists the known problems with the CSDADC middleware:</p>
<table class="doxtable">
<tr>
<th>Cypress ID</th><th>Known Issue</th><th>Workaround </th></tr>
<tr>
<td>319100 </td><td>The GPIO simultaneous operation with unrestricted strength and frequency creates noise that can affect the CSDADC operation.  </td><td>Refer to the errata section of the device datasheet for details.<br />
 <a href="http://www.cypress.com/ds218787"><b>PSoC 63 with BLE Datasheet Programmable System-on-Chip</b></a>   </td></tr>
</table>
<h1><a class="anchor" id="group_csdadc_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td rowspan="8">2.0 </td><td>Made public the CY_CSDADC_NO_CHANNEL macro </td><td>Defect fixing  </td></tr>
<tr>
<td>Changed the <a class="el" href="group__group__csdadc__functions.html#ga514703b9e2da7cc3adf497198558e9b0" title="Implements the interrupt service routine for the CSDADC middleware. ">Cy_CSDADC_InterruptHandler()</a> function prototype. Added function argument: const CSD_Type * base  </td><td>User experience improvement  </td></tr>
<tr>
<td>Changed the <a class="el" href="group__group__csdadc__functions.html#ga2fe1d5b92fcbbb85230cce544818ce59" title="Initiates an analog-to-digital conversion. ">Cy_CSDADC_StartConvert()</a> function prototype. Changed the mode argument type from uint32_t to cy_en_csdadc_conversion_mode_t </td><td>User experience improvement  </td></tr>
<tr>
<td>Renamed function Cy_CSDADC_ConversionStatus() to <a class="el" href="group__group__csdadc__functions.html#ga984982a9e928f7380555ee375384915a" title="The function returns a current CSDADC conversion status. ">Cy_CSDADC_GetConversionStatus()</a> </td><td>User experience improvement  </td></tr>
<tr>
<td>The CSDADC MW sources are enclosed with the conditional compilation to ensure a successful compilation for non-CSDADC-capable devices </td><td>A compilation for non-CSDADC-capable devices  </td></tr>
<tr>
<td>After conversion, the ADC channel is still connected to the CSD HW block, and disconnected only prior to new channel connection </td><td>Defect fixing  </td></tr>
<tr>
<td>Changed the <a class="el" href="structcy__stc__csdadc__config__t.html" title="CSDADC configuration structure. ">cy_stc_csdadc_config_t</a> structure: the ptrPin field is replaced with the ptrPinList field. It is a pointer to the array of the size determined by the numChannels field of this structure versus the ptrPin field that was an array of pointers with fixed <a class="el" href="group__group__csdadc__macros.html#ga7a2c27abd3dd05754a37d9accbc7fa49">CY_CSDADC_MAX_CHAN_NUM</a> size. </td><td>User experience improvement  </td></tr>
<tr>
<td>Added the cpuClk field to the <a class="el" href="structcy__stc__csdadc__config__t.html" title="CSDADC configuration structure. ">cy_stc_csdadc_config_t</a> structure. Changed the software watchdog counter calculation in the <a class="el" href="group__group__csdadc__functions.html#ga63d187dca4825b702bcdb5ff73a7aef7" title="Resumes the middleware operation if the Cy_CSDADC_Save() function was called previously. ">Cy_CSDADC_Restore()</a> function where cpuClk is used instead of periClk. </td><td>Defect fixing  </td></tr>
<tr>
<td rowspan="2">1.0.1 </td><td>Improvements to documentation </td><td>User experience improvement  </td></tr>
<tr>
<td>Forbidden usage of CSDADC for non-CSDADC-capable devices in module.mk file </td><td>A Compilation for non-CSDADC-capable devices  </td></tr>
<tr>
<td>1.0 </td><td>The initial version </td><td></td></tr>
</table>
<h1><a class="anchor" id="group_csdadc_more_information"></a>
More Information</h1>
<p>For more information, refer to the following documents:</p>
<ul>
<li><a href="https://www.cypress.com/products/modustoolbox-software-environment"><b>ModusToolbox Software Environment, Quick Start Guide, Documentation, and Videos</b></a></li>
<li><a href="https://github.com/cypresssemiconductorco"><b>CSDADC Middleware Code Example for MBED OS</b></a></li>
<li><a href="https://github.com/cypresssemiconductorco"><b>CSDADC Middleware Code Examples at GITHUB</b></a></li>
<li><a href="https://www.cypress.com/ModusToolboxDeviceConfig"><b>ModusToolbox Device Configurator Tool Guide</b></a></li>
<li><a href="https://cypresssemiconductorco.github.io/capsense/capsense_api_reference_manual/html/index.html"><b>CapSense Middleware API Reference Guide</b></a></li>
<li><a href="https://cypresssemiconductorco.github.io/csdidac/csdidac_api_reference_manual/html/index.html"><b>CSDIDAC Middleware API Reference Guide</b></a></li>
<li><a href="https://github.com/cypresssemiconductorco.github.io/psoc6pdl/pdl_api_reference_manual/html/index.html"><b>PDL API Reference</b></a></li>
<li><a href="https://www.cypress.com/documentation/technical-reference-manuals/psoc-6-mcu-psoc-63-ble-architecture-technical-reference"><b>PSoC 6 Technical Reference Manual</b></a></li>
<li><a href="http://www.cypress.com/ds218787"><b>PSoC 63 with BLE Datasheet Programmable System-on-Chip datasheet</b></a></li>
<li><a href="http://www.cypress.com"><b>Cypress Semiconductor</b></a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The links to another software component’s documentation (middleware and PDL) point to GitHub to the latest available version of the software. To get documentation of the specified version, download from GitHub and unzip the component archive. The documentation is available in the <em>docs</em> folder. </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>Cypress CSDADC Middleware Library 2.0</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
